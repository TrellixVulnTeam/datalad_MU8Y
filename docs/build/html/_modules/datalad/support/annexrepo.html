<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>datalad.support.annexrepo &mdash; DataLad 0.15.3+529.gc81453444.dirty documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> DataLad
            <img src="../../../_static/datalad_logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.15
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Change log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../acknowledgements.html">Acknowledgments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../publications.html">Publications</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../background.html">Background and motivation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../related.html">Delineation from related solutions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../basics.html">Basic principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../credentials.html">Credentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../metadata.html">Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../customization.html">Customization and extension of functionality</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../design/index.html">Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../cmdline.html">Command line reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modref.html">Python module reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../config.html">Configuration</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">DataLad</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>datalad.support.annexrepo</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for datalad.support.annexrepo</h1><div class="highlight"><pre>
<span></span><span class="c1"># emacs: -*- mode: python; py-indent-offset: 4; tab-width: 4; indent-tabs-mode: nil -*-</span>
<span class="c1"># ex: set sts=4 ts=4 sw=4 et:</span>
<span class="c1"># ## ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ##</span>
<span class="c1">#</span>
<span class="c1">#   See COPYING file distributed along with the datalad package for the</span>
<span class="c1">#   copyright and license terms.</span>
<span class="c1">#</span>
<span class="c1"># ## ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ##</span>
<span class="sd">&quot;&quot;&quot;Interface to git-annex by Joey Hess.</span>

<span class="sd">For further information on git-annex see https://git-annex.branchable.com/.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">cpu_count</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">linesep</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">curdir</span><span class="p">,</span>
    <span class="n">join</span> <span class="k">as</span> <span class="n">opj</span><span class="p">,</span>
    <span class="n">exists</span><span class="p">,</span>
    <span class="n">lexists</span><span class="p">,</span>
    <span class="n">isdir</span><span class="p">,</span>
    <span class="n">normpath</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">weakref</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">finalize</span><span class="p">,</span>
    <span class="n">WeakValueDictionary</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">datalad.cmd</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">BatchedCommand</span><span class="p">,</span>
    <span class="n">GitWitlessRunner</span><span class="p">,</span>
    <span class="c1"># KillOutput,</span>
    <span class="n">SafeDelCloseMixin</span><span class="p">,</span>
    <span class="n">StdOutCapture</span><span class="p">,</span>
    <span class="n">StdOutErrCapture</span><span class="p">,</span>
    <span class="n">WitlessProtocol</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">datalad.consts</span> <span class="kn">import</span> <span class="n">WEB_SPECIAL_REMOTE_UUID</span>
<span class="kn">from</span> <span class="nn">datalad.dochelpers</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">borrowdoc</span><span class="p">,</span>
    <span class="n">borrowkwargs</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">datalad.log</span> <span class="kn">import</span> <span class="n">log_progress</span>
<span class="kn">from</span> <span class="nn">datalad.runner.protocol</span> <span class="kn">import</span> <span class="n">GeneratorMixIn</span>
<span class="kn">from</span> <span class="nn">datalad.runner.utils</span> <span class="kn">import</span> <span class="n">LineSplitter</span>
<span class="c1"># must not be loads, because this one would log, and we need to log ourselves</span>
<span class="kn">from</span> <span class="nn">datalad.support.json_py</span> <span class="kn">import</span> <span class="n">json_loads</span>
<span class="kn">from</span> <span class="nn">datalad.support.exceptions</span> <span class="kn">import</span> <span class="n">CapturedException</span>
<span class="kn">from</span> <span class="nn">datalad.ui</span> <span class="kn">import</span> <span class="n">ui</span>
<span class="kn">import</span> <span class="nn">datalad.utils</span> <span class="k">as</span> <span class="nn">ut</span>
<span class="kn">from</span> <span class="nn">datalad.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">auto_repr</span><span class="p">,</span>
    <span class="n">ensure_list</span><span class="p">,</span>
    <span class="n">on_windows</span><span class="p">,</span>
    <span class="n">Path</span><span class="p">,</span>
    <span class="n">PurePosixPath</span><span class="p">,</span>
    <span class="n">split_cmdline</span><span class="p">,</span>
    <span class="n">unlink</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># imports from same module:</span>
<span class="kn">from</span> <span class="nn">datalad.dataset.repo</span> <span class="kn">import</span> <span class="n">RepoInterface</span>
<span class="kn">from</span> <span class="nn">.gitrepo</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">GitRepo</span><span class="p">,</span>
    <span class="n">normalize_path</span><span class="p">,</span>
    <span class="n">normalize_paths</span><span class="p">,</span>
    <span class="n">to_options</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.external_versions</span> <span class="kn">import</span> <span class="n">external_versions</span>
<span class="kn">from</span> <span class="nn">.exceptions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">CommandNotAvailableError</span><span class="p">,</span>
    <span class="n">CommandError</span><span class="p">,</span>
    <span class="n">FileNotInAnnexError</span><span class="p">,</span>
    <span class="n">FileInGitError</span><span class="p">,</span>
    <span class="n">AnnexBatchCommandError</span><span class="p">,</span>
    <span class="n">InsufficientArgumentsError</span><span class="p">,</span>
    <span class="n">OutOfSpaceError</span><span class="p">,</span>
    <span class="n">RemoteNotAvailableError</span><span class="p">,</span>
    <span class="n">OutdatedExternalDependency</span><span class="p">,</span>
    <span class="n">MissingExternalDependency</span><span class="p">,</span>
    <span class="n">NoSuchPathError</span><span class="p">,</span>
    <span class="n">IncompleteResultsError</span><span class="p">,</span>
    <span class="n">AccessDeniedError</span><span class="p">,</span>
    <span class="n">AccessFailedError</span><span class="p">,</span>
    <span class="n">InvalidAnnexRepositoryError</span><span class="p">,</span>
    <span class="n">InvalidGitRepositoryError</span><span class="p">,</span>
    <span class="n">DirectModeNoLongerSupportedError</span>
<span class="p">)</span>

<span class="n">lgr</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;datalad.annex&#39;</span><span class="p">)</span>

<span class="c1"># This is a map between an auto-upgradeable version and the version that it</span>
<span class="c1"># upgrades to. It should track autoUpgradeableVersions in Annex.Version.</span>
<span class="n">_AUTO_UPGRADEABLE_VERSIONS</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="mi">8</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">)}</span>


<div class="viewcode-block" id="AnnexRepo"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo">[docs]</a><span class="k">class</span> <span class="nc">AnnexRepo</span><span class="p">(</span><span class="n">GitRepo</span><span class="p">,</span> <span class="n">RepoInterface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Representation of an git-annex repository.</span>

<span class="sd">    Paths given to any of the class methods will be interpreted as relative</span>
<span class="sd">    to PWD, in case this is currently beneath AnnexRepo&#39;s base dir</span>
<span class="sd">    (`self.path`). If PWD is outside of the repository, relative paths</span>
<span class="sd">    will be interpreted as relative to `self.path`. Absolute paths will be</span>
<span class="sd">    accepted either way.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Begin Flyweight:</span>
    <span class="n">_unique_instances</span> <span class="o">=</span> <span class="n">WeakValueDictionary</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_flyweight_invalid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid_annex</span><span class="p">(</span><span class="n">allow_noninitialized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># End Flyweight:</span>

    <span class="c1"># Web remote UUID, kept here for backward compatibility</span>
    <span class="n">WEB_UUID</span> <span class="o">=</span> <span class="n">WEB_SPECIAL_REMOTE_UUID</span>

    <span class="c1"># To be assigned and checked to be good enough upon first call to AnnexRepo</span>
    <span class="c1"># 6.20160923 -- --json-progress for get</span>
    <span class="c1"># 6.20161210 -- annex add  to add also changes (not only new files) to git</span>
    <span class="c1"># 6.20170220 -- annex status provides --ignore-submodules</span>
    <span class="c1"># 6.20180416 -- annex handles unicode filenames more uniformly</span>
    <span class="c1"># 6.20180913 -- annex fixes all known to us issues for v6</span>
    <span class="c1"># 7          -- annex makes v7 mode default on crippled systems. We demand it for consistent operation</span>
    <span class="c1"># 7.20190503 -- annex introduced mimeencoding support needed for our text2git</span>
    <span class="c1">#</span>
    <span class="c1"># When bumping this, check whether datalad.repo.version needs to be</span>
    <span class="c1"># adjusted.</span>
    <span class="n">GIT_ANNEX_MIN_VERSION</span> <span class="o">=</span> <span class="s1">&#39;8.20200309&#39;</span>
    <span class="n">git_annex_version</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">supports_direct_mode</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">repository_versions</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_version_kludges</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Class wide setting to allow insecure URLs. Used during testing, since</span>
    <span class="c1"># git annex 6.20180626 those will by default be not allowed for security</span>
    <span class="c1"># reasons</span>
    <span class="n">_ALLOW_LOCAL_URLS</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">runner</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">backend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">always_commit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">create</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">create_sanity_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">git_opts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">annex_opts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">annex_init_opts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">repo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fake_dates</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates representation of git-annex repository at `path`.</span>

<span class="sd">        AnnexRepo is initialized by giving a path to the annex.</span>
<span class="sd">        If no annex exists at that location, a new one is created.</span>
<span class="sd">        Optionally give url to clone from.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path: str</span>
<span class="sd">          Path to git-annex repository. In case it&#39;s not an absolute path, it&#39;s</span>
<span class="sd">          relative to PWD</span>
<span class="sd">        runner: Runner, optional</span>
<span class="sd">          Provide a Runner in case AnnexRepo shall not create it&#39;s own.</span>
<span class="sd">          This is especially needed in case of desired dry runs.</span>
<span class="sd">        backend: str, optional</span>
<span class="sd">          Set default backend used by this annex. This does NOT affect files,</span>
<span class="sd">          that are already annexed nor will it automatically migrate files,</span>
<span class="sd">          hat are &#39;getted&#39; afterwards.</span>
<span class="sd">        create: bool, optional</span>
<span class="sd">          Create and initialize an annex repository at path, in case</span>
<span class="sd">          there is none. If set to False, and this repository is not an annex</span>
<span class="sd">          repository (initialized or not), an exception is raised.</span>
<span class="sd">        create_sanity_checks: bool, optional</span>
<span class="sd">          Passed to GitRepo.</span>
<span class="sd">        init: bool, optional</span>
<span class="sd">          Initialize git-annex repository (run &quot;git annex init&quot;) if path is an</span>
<span class="sd">          annex repository which just was not yet initialized by annex (e.g. a</span>
<span class="sd">          fresh git clone). Note that if `create=True`, then initialization</span>
<span class="sd">          would happen</span>
<span class="sd">        batch_size: int, optional</span>
<span class="sd">          If specified and &gt;0, instructs annex to batch this many commands before</span>
<span class="sd">          annex adds acts on git repository (e.g. adds them them to index for addurl).</span>
<span class="sd">        version: int, optional</span>
<span class="sd">          If given, pass as --version to `git annex init`</span>
<span class="sd">        description: str, optional</span>
<span class="sd">          Short description that humans can use to identify the</span>
<span class="sd">          repository/location, e.g. &quot;Precious data on my laptop&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># BEGIN Repo validity test</span>
        <span class="c1"># We want to fail early for tests, that would be performed a lot. In particular this is about</span>
        <span class="c1"># AnnexRepo.is_valid_repo. We would use the latter to decide whether or not to call AnnexRepo() only for</span>
        <span class="c1"># __init__ to then test the same things again. If we fail early we can save the additional test from outer</span>
        <span class="c1"># scope.</span>
        <span class="n">do_init</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AnnexRepo</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">path</span><span class="p">,</span> <span class="n">runner</span><span class="o">=</span><span class="n">runner</span><span class="p">,</span>
            <span class="n">create</span><span class="o">=</span><span class="n">create</span><span class="p">,</span> <span class="n">create_sanity_checks</span><span class="o">=</span><span class="n">create_sanity_checks</span><span class="p">,</span>
            <span class="n">repo</span><span class="o">=</span><span class="n">repo</span><span class="p">,</span> <span class="n">git_opts</span><span class="o">=</span><span class="n">git_opts</span><span class="p">,</span> <span class="n">fake_dates</span><span class="o">=</span><span class="n">fake_dates</span><span class="p">)</span>

        <span class="c1"># Check whether an annex already exists at destination</span>
        <span class="c1"># XXX this doesn&#39;t work for a submodule!</span>

        <span class="c1"># NOTE: We are in __init__ here and already know that GitRepo.is_valid_git is True, since super.__init__  was</span>
        <span class="c1">#       called. Therefore: check_git=False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid_annex</span><span class="p">(</span><span class="n">check_git</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="c1"># so either it is not annex at all or just was not yet initialized</span>
            <span class="c1"># TODO: There&#39;s still potential to get a bit more performant. is_with_annex() is checking again, what</span>
            <span class="c1">#       is_valid_annex did. However, this marginal here, considering the call to git-annex-init.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_with_annex</span><span class="p">():</span>
                <span class="c1"># it is an annex repository which was not initialized yet</span>
                <span class="k">if</span> <span class="n">create</span> <span class="ow">or</span> <span class="n">init</span><span class="p">:</span>
                    <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Annex repository was not yet initialized at </span><span class="si">%s</span><span class="s1">.&#39;</span>
                              <span class="s1">&#39; Initializing ...&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
                    <span class="n">do_init</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">create</span><span class="p">:</span>
                <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Initializing annex repository at </span><span class="si">%s</span><span class="s1">...&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
                <span class="n">do_init</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InvalidAnnexRepositoryError</span><span class="p">(</span><span class="s2">&quot;No annex found at </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

        <span class="c1"># END Repo validity test</span>

        <span class="c1"># initialize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_uuid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_annex_common_options</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;-c&quot;</span><span class="p">,</span> <span class="s2">&quot;annex.dotfiles=true&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">annex_opts</span> <span class="ow">or</span> <span class="n">annex_init_opts</span><span class="p">:</span>
            <span class="n">lgr</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;TODO: options passed to git-annex and/or &quot;</span>
                        <span class="s2">&quot;git-annex-init are currently ignored.</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;options received:</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;git-annex: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">git-annex-init: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                        <span class="p">(</span><span class="n">annex_opts</span><span class="p">,</span> <span class="n">annex_init_opts</span><span class="p">))</span>

        <span class="c1"># Below was initially introduced for setting for direct mode workaround,</span>
        <span class="c1"># where we changed _GIT_COMMON_OPTIONS and had to avoid passing</span>
        <span class="c1"># --worktree=. -c core.bare=False to git annex commands, so for their</span>
        <span class="c1"># invocation we kept and used pristine version of the</span>
        <span class="c1"># common options.  yoh thought it would be good to keep this as a copy</span>
        <span class="c1"># just in case we do need to pass annex specific options, even if</span>
        <span class="c1"># there is no need ATM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ANNEX_GIT_COMMON_OPTIONS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GIT_COMMON_OPTIONS</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">always_commit</span> <span class="o">=</span> <span class="n">always_commit</span>

        <span class="n">config</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span>
        <span class="k">if</span> <span class="n">version</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">version</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;datalad.repo.version&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="c1"># we might get an empty string here</span>
            <span class="c1"># TODO: if we use obtain() instead, we get an error complaining</span>
            <span class="c1"># &#39;&#39; cannot be converted to int (via Constraint as defined for</span>
            <span class="c1"># &quot;datalad.repo.version&quot; in common_cfg</span>
            <span class="c1"># =&gt; Allow conversion to result in None?</span>
            <span class="k">if</span> <span class="n">version</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">version</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">version</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="c1"># Just give a warning if things look off and let</span>
                    <span class="c1"># git-annex-init complain if it can&#39;t actually handle it.</span>
                    <span class="n">lgr</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="s2">&quot;Expected an int for datalad.repo.version, got </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">version</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># The above comment refers to an empty string case. The commit</span>
                <span class="c1"># (f12eb03f40) seems to deal with direct mode, so perhaps this</span>
                <span class="c1"># isn&#39;t reachable anymore.</span>
                <span class="n">version</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">do_init</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init</span><span class="p">(</span><span class="n">version</span><span class="o">=</span><span class="n">version</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">)</span>

        <span class="c1"># TODO: RM DIRECT  eventually, but should remain while we have is_direct_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_direct_mode</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Handle cases of detecting repositories with no longer supported</span>
        <span class="c1"># direct mode.</span>
        <span class="c1"># Could happen in case we didn&#39;t specify anything, but annex forced</span>
        <span class="c1"># direct mode due to FS or an already existing repo was in direct mode,</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_direct_mode_from_config</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">DirectModeNoLongerSupportedError</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="s2">&quot;Git configuration reports repository being in direct mode&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">getbool</span><span class="p">(</span><span class="s2">&quot;datalad&quot;</span><span class="p">,</span> <span class="s2">&quot;repo.direct&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DirectModeNoLongerSupportedError</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="s2">&quot;datalad.repo.direct configuration instructs to use direct mode&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_batched</span> <span class="o">=</span> <span class="n">BatchedAnnexes</span><span class="p">(</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">git_options</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ANNEX_GIT_COMMON_OPTIONS</span><span class="p">)</span>

        <span class="c1"># set default backend for future annex commands:</span>
        <span class="c1"># TODO: Should the backend option of __init__() also migrate</span>
        <span class="c1"># the annex, in case there are annexed files already?</span>
        <span class="k">if</span> <span class="n">backend</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_default_backend</span><span class="p">(</span><span class="n">backend</span><span class="p">,</span> <span class="n">persistent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ALLOW_LOCAL_URLS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_allow_local_urls</span><span class="p">()</span>

        <span class="c1"># will be evaluated lazily</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_auto_jobs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Finally, register a finalizer (instead of having a __del__ method).</span>
        <span class="c1"># This will be called by garbage collection as well as &quot;atexit&quot;. By</span>
        <span class="c1"># keeping the reference here, we can also call it explicitly.</span>
        <span class="c1"># Note, that we can pass required attributes to the finalizer, but not</span>
        <span class="c1"># `self` itself. This would create an additional reference to the object</span>
        <span class="c1"># and thereby preventing it from being collected at all.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalizer</span> <span class="o">=</span> <span class="n">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">AnnexRepo</span><span class="o">.</span><span class="n">_cleanup</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">_batched</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_allow_local_urls</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Allow URL schemes and addresses which potentially could be harmful.</span>

<span class="sd">        For now it is internal method used within tests only</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># from annex 6.20180626 file:/// and http://localhost access isn&#39;t</span>
        <span class="c1"># allowed by default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
            <span class="s1">&#39;annex.security.allowed-url-schemes&#39;</span><span class="p">,</span> <span class="s1">&#39;http https file&#39;</span><span class="p">,</span>
            <span class="s1">&#39;local&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
            <span class="s1">&#39;annex.security.allowed-http-addresses&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span>
            <span class="s1">&#39;local&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="AnnexRepo.set_default_backend"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.set_default_backend">[docs]</a>    <span class="k">def</span> <span class="nf">set_default_backend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">persistent</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">commit</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set default backend</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        backend : str</span>
<span class="sd">        persistent : bool, optional</span>
<span class="sd">          If persistent, would add/commit to .gitattributes. If not -- would</span>
<span class="sd">          set within .git/config</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">persistent</span><span class="p">:</span>
            <span class="c1"># could be set in .gitattributes or $GIT_DIR/info/attributes</span>
            <span class="k">if</span> <span class="s1">&#39;annex.backend&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gitattributes</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="s1">&#39;.&#39;</span><span class="p">]:</span>
                <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;Not (re)setting backend since seems already set in git attributes&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Setting annex backend to </span><span class="si">%s</span><span class="s2"> (persistently)&quot;</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span>
                <span class="n">git_attributes_file</span> <span class="o">=</span> <span class="s1">&#39;.gitattributes&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_gitattributes</span><span class="p">(</span>
                    <span class="p">[(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;annex.backend&#39;</span><span class="p">:</span> <span class="n">backend</span><span class="p">})],</span>
                    <span class="n">git_attributes_file</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">git_attributes_file</span><span class="p">,</span> <span class="n">git</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">commit</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">(</span>
                        <span class="s2">&quot;Set default backend for all files to be </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">backend</span><span class="p">,</span>
                        <span class="n">_datalad_msg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">files</span><span class="o">=</span><span class="p">[</span><span class="n">git_attributes_file</span><span class="p">]</span>
                    <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Setting annex backend to </span><span class="si">%s</span><span class="s2"> (in .git/config)&quot;</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;annex.backend&#39;</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s1">&#39;local&#39;</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_cleanup</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">batched</span><span class="p">):</span>

        <span class="n">lgr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Finalizer called on: AnnexRepo(</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>

        <span class="c1"># Ben: With switching to finalize rather than del, I think the</span>
        <span class="c1">#      safe_del_debug isn&#39;t needed anymore. However, time will tell and</span>
        <span class="c1">#      it doesn&#39;t hurt.</span>

        <span class="k">def</span> <span class="nf">safe__del__debug</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;We might be too late in the game and either .debug or exc_str</span>
<span class="sd">            are no longer bound&quot;&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">NameError</span><span class="p">):</span>
                <span class="k">return</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">batched</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">batched</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Workaround:</span>
            <span class="c1"># most likely something wasn&#39;t accessible anymore; doesn&#39;t really</span>
            <span class="c1"># matter since we wanted to delete it anyway.</span>
            <span class="c1">#</span>
            <span class="c1"># Nevertheless, in some cases might be an issue and it is a strange</span>
            <span class="c1"># thing to happen, since we check for things being None herein as</span>
            <span class="c1"># well as in super class __del__;</span>
            <span class="c1"># At least log it:</span>
            <span class="n">safe__del__debug</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

<div class="viewcode-block" id="AnnexRepo.is_managed_branch"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.is_managed_branch">[docs]</a>    <span class="k">def</span> <span class="nf">is_managed_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">branch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Whether `branch` is managed by git-annex.</span>

<span class="sd">        ATM this returns True if on an adjusted branch of annex v6+ repository:</span>
<span class="sd">        either &#39;adjusted/my_branch(unlocked)&#39; or &#39;adjusted/my_branch(fixed)&#39;</span>

<span class="sd">        Note: The term &#39;managed branch&#39; is used to make clear it&#39;s meant to be</span>
<span class="sd">        more general than the v6+ &#39;adjusted branch&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        branch: str</span>
<span class="sd">          name of the branch; default: active branch</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">          True if on a managed branch, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">branch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_active_branch</span><span class="p">()</span>
        <span class="c1"># Note: `branch` might still be None, due to detached HEAD</span>
        <span class="c1"># (or no checkout at all)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">branch</span> <span class="ow">and</span> <span class="n">branch</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;adjusted/&#39;</span><span class="p">))</span></div>

<div class="viewcode-block" id="AnnexRepo.get_corresponding_branch"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.get_corresponding_branch">[docs]</a>    <span class="k">def</span> <span class="nf">get_corresponding_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">branch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the name of a potential corresponding branch.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        branch: str, optional</span>
<span class="sd">          Name of the branch to report a corresponding branch for;</span>
<span class="sd">          defaults to active branch</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str or None</span>
<span class="sd">          Name of the corresponding branch, or `None` if there is no</span>
<span class="sd">          corresponding branch.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">branch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_active_branch</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_managed_branch</span><span class="p">(</span><span class="n">branch</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">branch</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;adjusted/&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">branch</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;(unlocked)&#39;</span><span class="p">):</span>
                    <span class="n">cor_branch</span> <span class="o">=</span> <span class="n">branch</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">branch</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;(fixed)&#39;</span><span class="p">):</span>
                    <span class="n">cor_branch</span> <span class="o">=</span> <span class="n">branch</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="o">-</span><span class="mi">7</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cor_branch</span> <span class="o">=</span> <span class="n">branch</span><span class="p">[</span><span class="mi">9</span><span class="p">:]</span>
                    <span class="n">lgr</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Unexpected naming of adjusted branch &#39;</span><span class="si">{}</span><span class="s2">&#39;.</span><span class="si">{}</span><span class="s2">&quot;</span>
                                <span class="s2">&quot;Assuming &#39;</span><span class="si">{}</span><span class="s2">&#39; to be the corresponding branch.&quot;</span>
                                <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span> <span class="n">linesep</span><span class="p">,</span> <span class="n">cor_branch</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Detection of annex-managed branch &#39;</span><span class="si">{}</span><span class="s2">&#39; follows a pattern &quot;</span>
                    <span class="s2">&quot;not implemented herein.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">branch</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">cor_branch</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="AnnexRepo.get_tracking_branch"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.get_tracking_branch">[docs]</a>    <span class="k">def</span> <span class="nf">get_tracking_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">branch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remote_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">corresponding</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the tracking branch for `branch` if there is any.</span>

<span class="sd">        By default returns the tracking branch of the corresponding branch if</span>
<span class="sd">        `branch` is a managed branch.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        branch: str</span>
<span class="sd">          local branch to look up. If none is given, active branch is used.</span>
<span class="sd">        remote_only : bool</span>
<span class="sd">            Don&#39;t return a value if the upstream remote is set to &quot;.&quot; (meaning</span>
<span class="sd">            this repository).</span>
<span class="sd">        corresponding: bool</span>
<span class="sd">          If True actually look up the corresponding branch of `branch` (also if</span>
<span class="sd">          `branch` isn&#39;t explicitly given)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            (remote or None, refspec or None) of the tracking branch</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">branch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_active_branch</span><span class="p">()</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">AnnexRepo</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_tracking_branch</span><span class="p">(</span>
            <span class="n">remote_only</span><span class="o">=</span><span class="n">remote_only</span><span class="p">,</span>
            <span class="n">branch</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_corresponding_branch</span><span class="p">(</span><span class="n">branch</span><span class="p">)</span> <span class="ow">or</span> <span class="n">branch</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">corresponding</span> <span class="k">else</span> <span class="n">branch</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_check_git_annex_version</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="n">ver</span> <span class="o">=</span> <span class="n">external_versions</span><span class="p">[</span><span class="s1">&#39;cmd:annex&#39;</span><span class="p">]</span>
        <span class="c1"># in case it is missing</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Visit http://handbook.datalad.org/r.html?install &quot;</span> \
              <span class="s2">&quot;for instructions on how to install DataLad and git-annex.&quot;</span>

        <span class="n">exc_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;git-annex&quot;</span><span class="p">,</span>
            <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">,</span>
            <span class="n">ver</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">GIT_ANNEX_MIN_VERSION</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ver</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MissingExternalDependency</span><span class="p">(</span><span class="o">**</span><span class="n">exc_kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ver</span> <span class="o">&lt;</span> <span class="bp">cls</span><span class="o">.</span><span class="n">GIT_ANNEX_MIN_VERSION</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OutdatedExternalDependency</span><span class="p">(</span><span class="n">ver_present</span><span class="o">=</span><span class="n">ver</span><span class="p">,</span> <span class="o">**</span><span class="n">exc_kwargs</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">git_annex_version</span> <span class="o">=</span> <span class="n">ver</span>

<div class="viewcode-block" id="AnnexRepo.check_direct_mode_support"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.check_direct_mode_support">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">check_direct_mode_support</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Does git-annex version support direct mode?</span>

<span class="sd">        The result is cached at `cls.supports_direct_mode`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">supports_direct_mode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;DataLad&#39;s minimum git-annex version is above 7.20190912, &quot;</span>
                <span class="s2">&quot;the last version to support direct mode. &quot;</span>
                <span class="s2">&quot;The check_direct_mode_support method &quot;</span>
                <span class="s2">&quot;and supports_direct_mode attribute will be removed &quot;</span>
                <span class="s2">&quot;in an upcoming release.&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">supports_direct_mode</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">supports_direct_mode</span></div>

<div class="viewcode-block" id="AnnexRepo.check_repository_versions"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.check_repository_versions">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">check_repository_versions</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get information on supported and upgradable repository versions.</span>

<span class="sd">        The result is cached at `cls.repository_versions`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">          supported -&gt; list of supported versions (int)</span>
<span class="sd">          upgradable -&gt; list of upgradable versions (int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">repository_versions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key_remap</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;supported repository versions&quot;</span><span class="p">:</span> <span class="s2">&quot;supported&quot;</span><span class="p">,</span>
                <span class="s2">&quot;upgrade supported from repository versions&quot;</span><span class="p">:</span> <span class="s2">&quot;upgradable&quot;</span><span class="p">}</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">GitWitlessRunner</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">(</span>
                <span class="p">[</span><span class="s2">&quot;git&quot;</span><span class="p">,</span> <span class="s2">&quot;annex&quot;</span><span class="p">,</span> <span class="s2">&quot;version&quot;</span><span class="p">],</span>
                <span class="n">protocol</span><span class="o">=</span><span class="n">StdOutErrCapture</span><span class="p">)</span>
            <span class="n">kvs</span> <span class="o">=</span> <span class="p">(</span><span class="n">ln</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">ln</span> <span class="ow">in</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;stdout&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">splitlines</span><span class="p">())</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">repository_versions</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">key_remap</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kvs</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">key_remap</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">repository_versions</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_check_version_kludges</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cache some annex-version-specific kludges in one go.</span>

<span class="sd">        Return the kludge under `key`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kludges</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_version_kludges</span>
        <span class="k">if</span> <span class="n">kludges</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">kludges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">git_annex_version</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_check_git_annex_version</span><span class="p">()</span>

        <span class="n">ver</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">git_annex_version</span>
        <span class="n">kludges</span><span class="p">[</span><span class="s2">&quot;fromkey-supports-unlocked&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ver</span> <span class="o">&gt;</span> <span class="s2">&quot;8.20210428&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_version_kludges</span> <span class="o">=</span> <span class="n">kludges</span>
        <span class="k">return</span> <span class="n">kludges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

<div class="viewcode-block" id="AnnexRepo.get_size_from_key"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.get_size_from_key">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_size_from_key</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A little helper to obtain size encoded in a key</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int or None</span>
<span class="sd">          size of the file or None if either no size is encoded in the key or</span>
<span class="sd">          key was None itself</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">          if key is considered invalid (at least its size-related part)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># see: https://git-annex.branchable.com/internals/key_format/</span>
        <span class="n">key_parts</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
        <span class="n">key_fields</span> <span class="o">=</span> <span class="n">key_parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
        <span class="n">parsed</span> <span class="o">=</span> <span class="p">{</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="nb">int</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="k">if</span> <span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="k">else</span> <span class="kc">None</span>
                  <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">key_fields</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                  <span class="k">if</span> <span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;sSC&quot;</span><span class="p">}</span>

        <span class="c1"># don&#39;t lookup the dict for the same things several times;</span>
        <span class="c1"># Is there a faster (and more compact) way of doing this? Note, that</span>
        <span class="c1"># locals() can&#39;t be updated.</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">parsed</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">parsed</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">parsed</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">C</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span>  <span class="c1"># also okay if s is None as well -&gt; no size to report</span>
        <span class="k">elif</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># s is None, while S and/or C are not.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid key: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">S</span> <span class="ow">and</span> <span class="n">C</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">C</span> <span class="o">&lt;=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span> <span class="o">/</span> <span class="n">S</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">S</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">s</span> <span class="o">%</span> <span class="n">S</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># S or C are given with the respective other one missing</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid key: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span></div>

<div class="viewcode-block" id="AnnexRepo.get_file_size"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.get_file_size">[docs]</a>    <span class="nd">@normalize_path</span>
    <span class="k">def</span> <span class="nf">get_file_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="n">fpath</span> <span class="o">=</span> <span class="n">opj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">fpath</span><span class="p">)</span> <span class="k">else</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">fpath</span><span class="p">)</span><span class="o">.</span><span class="n">st_size</span></div>

<div class="viewcode-block" id="AnnexRepo.is_initialized"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.is_initialized">[docs]</a>    <span class="k">def</span> <span class="nf">is_initialized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;quick check whether this appears to be an annex-init&#39;ed repo</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># intended to avoid calling self._init, when it&#39;s not needed, since this check is clearly</span>
        <span class="c1"># cheaper than git-annex-init (which would be safe to just call)</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dot_git</span> <span class="o">/</span> <span class="s1">&#39;annex&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span></div>

<div class="viewcode-block" id="AnnexRepo.is_valid_annex"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.is_valid_annex">[docs]</a>    <span class="nd">@borrowdoc</span><span class="p">(</span><span class="n">GitRepo</span><span class="p">,</span> <span class="s1">&#39;is_valid_git&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">is_valid_annex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allow_noninitialized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_git</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="n">initialized_annex</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_valid_git</span><span class="p">()</span> <span class="k">if</span> <span class="n">check_git</span> <span class="k">else</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dot_git</span> <span class="o">/</span> <span class="s1">&#39;annex&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">allow_noninitialized</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">initialized_annex</span> <span class="ow">or</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">is_valid_git</span><span class="p">()</span> <span class="k">if</span> <span class="n">check_git</span> <span class="k">else</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_with_annex</span><span class="p">())</span>
            <span class="k">except</span> <span class="p">(</span><span class="n">NoSuchPathError</span><span class="p">,</span> <span class="n">InvalidGitRepositoryError</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">initialized_annex</span></div>

<div class="viewcode-block" id="AnnexRepo.is_valid_repo"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.is_valid_repo">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">is_valid_repo</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">allow_noninitialized</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if given path points to an annex repository</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">git_file_has_annex</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Return True if `p` contains a .git file, that points to a git</span>
<span class="sd">            dir with a subdir &#39;annex&#39;&quot;&quot;&quot;</span>
            <span class="n">_git</span> <span class="o">=</span> <span class="n">opj</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s1">&#39;.git&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">_git</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">_git</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;gitdir: &quot;</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">exists</span><span class="p">(</span><span class="n">opj</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">line</span><span class="p">[</span><span class="mi">8</span><span class="p">:],</span> <span class="s1">&#39;annex&#39;</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Invalid .git file: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">_git</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="n">initialized_annex</span> <span class="o">=</span> <span class="n">GitRepo</span><span class="o">.</span><span class="n">is_valid_repo</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="ow">and</span> \
                            <span class="p">(</span><span class="n">exists</span><span class="p">(</span><span class="n">opj</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;.git&#39;</span><span class="p">,</span> <span class="s1">&#39;annex&#39;</span><span class="p">))</span> <span class="ow">or</span>
                             <span class="n">git_file_has_annex</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">allow_noninitialized</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">initialized_annex</span> <span class="ow">or</span> <span class="n">GitRepo</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">create</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">is_with_annex</span><span class="p">()</span>
            <span class="k">except</span> <span class="p">(</span><span class="n">NoSuchPathError</span><span class="p">,</span> <span class="n">InvalidGitRepositoryError</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">initialized_annex</span></div>

<div class="viewcode-block" id="AnnexRepo.set_remote_url"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.set_remote_url">[docs]</a>    <span class="k">def</span> <span class="nf">set_remote_url</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">push</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the URL a remote is pointing to</span>

<span class="sd">        Sets the URL of the remote `name`. Requires the remote to already exist.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name: str</span>
<span class="sd">          name of the remote</span>
<span class="sd">        url: str</span>
<span class="sd">        push: bool</span>
<span class="sd">          if True, set the push URL, otherwise the fetch URL;</span>
<span class="sd">          if True, additionally set annexurl to `url`, to make sure annex uses</span>
<span class="sd">          it to talk to the remote, since access via fetch URL might be</span>
<span class="sd">          restricted.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">push</span><span class="p">:</span>
            <span class="c1"># if we are to set a push url, also set &#39;annexUrl&#39; for this remote,</span>
            <span class="c1"># in order to make git-annex use it, when talking to the remote.</span>
            <span class="c1"># (see http://git-annex.branchable.com/bugs/annex_ignores_pushurl_and_uses_only_url_upon___34__copy_--to__34__/)</span>
            <span class="n">var</span> <span class="o">=</span> <span class="s1">&#39;remote.</span><span class="si">{0}</span><span class="s1">.</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;annexurl&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s1">&#39;local&#39;</span><span class="p">,</span> <span class="n">reload</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AnnexRepo</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_remote_url</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">push</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnexRepo.set_remote_dead"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.set_remote_dead">[docs]</a>    <span class="k">def</span> <span class="nf">set_remote_dead</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Announce to annex that remote is &quot;dead&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_annex</span><span class="p">([</span><span class="s2">&quot;dead&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">])</span></div>

<div class="viewcode-block" id="AnnexRepo.is_remote_annex_ignored"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.is_remote_annex_ignored">[docs]</a>    <span class="k">def</span> <span class="nf">is_remote_annex_ignored</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remote</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if remote is explicitly ignored&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">getbool</span><span class="p">(</span>
            <span class="s1">&#39;remote.</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">remote</span><span class="p">),</span> <span class="s1">&#39;annex-ignore&#39;</span><span class="p">,</span>
            <span class="n">default</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="AnnexRepo.is_special_annex_remote"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.is_special_annex_remote">[docs]</a>    <span class="k">def</span> <span class="nf">is_special_annex_remote</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remote</span><span class="p">,</span> <span class="n">check_if_known</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether remote is a special annex remote</span>

<span class="sd">        Decides based on the presence of an annex- option and lack of a</span>
<span class="sd">        configured URL for the remote.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">check_if_known</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">remote</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_remotes</span><span class="p">():</span>
                <span class="k">raise</span> <span class="n">RemoteNotAvailableError</span><span class="p">(</span><span class="n">remote</span><span class="p">)</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="s1">&#39;remote.</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">remote</span><span class="p">))</span>
        <span class="k">if</span> <span class="s2">&quot;url&quot;</span> <span class="ow">in</span> <span class="n">opts</span><span class="p">:</span>
            <span class="n">is_special</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;annex-&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">opts</span>
                 <span class="k">if</span> <span class="n">o</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;annex-uuid&quot;</span><span class="p">,</span> <span class="s2">&quot;annex-ignore&quot;</span><span class="p">]):</span>
            <span class="c1"># It&#39;s possible that there isn&#39;t a special-remote related option</span>
            <span class="c1"># (we only filter out a few common ones), but given that there is</span>
            <span class="c1"># no URL it should be a good bet that this is a special remote.</span>
            <span class="n">is_special</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_special</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">lgr</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Remote &#39;</span><span class="si">%s</span><span class="s2">&#39; has no URL or annex- option. &quot;</span>
                        <span class="s2">&quot;Is it mis-configured?&quot;</span><span class="p">,</span>
                        <span class="n">remote</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">is_special</span></div>

<div class="viewcode-block" id="AnnexRepo.get_remotes"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.get_remotes">[docs]</a>    <span class="nd">@borrowkwargs</span><span class="p">(</span><span class="n">GitRepo</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_remotes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">with_urls_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">exclude_special_remotes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get known (special-) remotes of the repository</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        exclude_special_remotes: bool, optional</span>
<span class="sd">          if True, don&#39;t return annex special remotes</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        remotes : list of str</span>
<span class="sd">          List of names of the remotes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">remotes</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">AnnexRepo</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_remotes</span><span class="p">(</span><span class="n">with_urls_only</span><span class="o">=</span><span class="n">with_urls_only</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exclude_special_remotes</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">remote</span> <span class="k">for</span> <span class="n">remote</span> <span class="ow">in</span> <span class="n">remotes</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_special_annex_remote</span><span class="p">(</span><span class="n">remote</span><span class="p">,</span> <span class="n">check_if_known</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">remotes</span></div>

<div class="viewcode-block" id="AnnexRepo.get_special_remotes"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.get_special_remotes">[docs]</a>    <span class="k">def</span> <span class="nf">get_special_remotes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get info about all known (not just enabled) special remotes.</span>

<span class="sd">        The present implementation is not able to report on special remotes</span>
<span class="sd">        that have only been configured in a private annex repo</span>
<span class="sd">        (annex.private=true).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">          Keys are special remote UUIDs. Each value is a dictionary with</span>
<span class="sd">          configuration information git-annex has for the remote. This should</span>
<span class="sd">          include the &#39;type&#39; and &#39;name&#39; as well as any `initremote` parameters</span>
<span class="sd">          that git-annex stores.</span>

<span class="sd">          Note: This is a faithful translation of git-annex:remote.log with one</span>
<span class="sd">          exception. For a special remote initialized with the --sameas flag,</span>
<span class="sd">          git-annex stores the special remote name under the &quot;sameas-name&quot; key,</span>
<span class="sd">          we copy this value under the &quot;name&quot; key so that callers don&#39;t have to</span>
<span class="sd">          check two places for the name. If you need to detect whether you&#39;re</span>
<span class="sd">          working with a sameas remote, the presence of either &quot;sameas-name&quot; or</span>
<span class="sd">          &quot;sameas-uuid&quot; is a reliable indicator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">argspec</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^([^=]*)=(.*)$&#39;</span><span class="p">)</span>
        <span class="n">srs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># We provide custom implementation to access this metadata since ATM</span>
        <span class="c1"># no git-annex command exposes it on CLI.</span>
        <span class="c1">#</span>
        <span class="c1"># Information will potentially be obtained from remote.log within</span>
        <span class="c1"># git-annex branch, and git-annex&#39;s journal, which might exist e.g.</span>
        <span class="c1"># due to alwayscommit=false operations</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sources</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="nb">list</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">call_git_items_</span><span class="p">(</span>
                        <span class="p">[</span><span class="s1">&#39;cat-file&#39;</span><span class="p">,</span> <span class="s1">&#39;blob&#39;</span><span class="p">,</span> <span class="s1">&#39;git-annex:remote.log&#39;</span><span class="p">],</span>
                        <span class="n">read_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="n">CommandError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;Not a valid object name git-annex:remote.log&#39;</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">stderr</span><span class="p">:</span>
                <span class="c1"># no special remotes configures - might still be in the journal</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># some unforeseen error</span>
                <span class="k">raise</span> <span class="n">e</span>

        <span class="n">journal_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot_git</span> <span class="o">/</span> <span class="s2">&quot;annex&quot;</span> <span class="o">/</span> <span class="s2">&quot;journal&quot;</span> <span class="o">/</span> <span class="s2">&quot;remote.log&quot;</span>
        <span class="k">if</span> <span class="n">journal_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="n">sources</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">journal_path</span><span class="o">.</span><span class="n">read_text</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">sources</span><span class="p">):</span>
            <span class="c1"># be precise and split by spaces</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="c1"># special remote UUID</span>
            <span class="n">sr_id</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># the rest are config args for enableremote</span>
            <span class="n">sr_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">argspec</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="o">.</span><span class="n">groups</span><span class="p">()[:</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="k">if</span> <span class="s2">&quot;name&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sr_info</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">sr_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sameas-name&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">lgr</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="s2">&quot;Encountered git-annex remote without a name or &quot;</span>
                        <span class="s2">&quot;sameas-name value: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">sr_info</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sr_info</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
            <span class="n">srs</span><span class="p">[</span><span class="n">sr_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">sr_info</span>
        <span class="k">return</span> <span class="n">srs</span></div>

    <span class="k">def</span> <span class="nf">_call_annex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">StdOutErrCapture</span><span class="p">,</span>
                    <span class="n">git_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stdin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">merge_annex_branches</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal helper to run git-annex commands</span>

<span class="sd">        Standard command options are applied in addition to the given arguments,</span>
<span class="sd">        and certain error conditions are detected (if possible) and dedicated</span>
<span class="sd">        exceptions are raised.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args: list</span>
<span class="sd">          List of git-annex command arguments.</span>
<span class="sd">        files: list, optional</span>
<span class="sd">          If command passes list of files. If list is too long</span>
<span class="sd">          (by number of files or overall size) it will be split, and multiple</span>
<span class="sd">          command invocations will follow</span>
<span class="sd">        jobs : int or &#39;auto&#39;, optional</span>
<span class="sd">          If &#39;auto&#39;, the number of jobs will be determined automatically,</span>
<span class="sd">          informed by the configuration setting</span>
<span class="sd">          &#39;datalad.runtime.max-annex-jobs&#39;.</span>
<span class="sd">        protocol : WitlessProtocol, optional</span>
<span class="sd">          Protocol class to pass to GitWitlessRunner.run(). By default this is</span>
<span class="sd">          StdOutErrCapture, which will provide default logging behavior and</span>
<span class="sd">          guarantee that stdout/stderr are included in potential CommandError</span>
<span class="sd">          exception.</span>
<span class="sd">        git_options: list, optional</span>
<span class="sd">          Additional arguments for Git to include in the git-annex call</span>
<span class="sd">          (in a position prior to the &#39;annex&#39; subcommand.</span>
<span class="sd">        stdin: File-like, optional</span>
<span class="sd">          stdin to connect to the git-annex process. Only used when `files`</span>
<span class="sd">          is None.</span>
<span class="sd">        merge_annex_branches: bool, optional</span>
<span class="sd">          If False, annex.merge-annex-branches=false config will be set for</span>
<span class="sd">          git-annex call.  Useful for operations which are not intended to</span>
<span class="sd">          benefit from updating information about remote git-annexes</span>
<span class="sd">        **kwargs:</span>
<span class="sd">          Additional arguments are passed on to the WitlessProtocol constructor</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">          Return value of WitlessRunner.run(). The content of the dict is</span>
<span class="sd">          determined by the given `protocol`. By default, it provides git-annex&#39;s</span>
<span class="sd">          stdout and stderr (under these key names)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        CommandError</span>
<span class="sd">          If the call exits with a non-zero status.</span>

<span class="sd">        OutOfSpaceError</span>
<span class="sd">          If a corresponding statement was detected in git-annex&#39;s output on</span>
<span class="sd">          stderr. Only supported if the given protocol captured stderr.</span>

<span class="sd">        RemoteNotAvailableError</span>
<span class="sd">          If a corresponding statement was detected in git-annex&#39;s output on</span>
<span class="sd">          stderr. Only supported if the given protocol captured stderr.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">git_annex_version</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_git_annex_version</span><span class="p">()</span>

        <span class="c1"># git portion of the command</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;git&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ANNEX_GIT_COMMON_OPTIONS</span>

        <span class="k">if</span> <span class="n">git_options</span><span class="p">:</span>
            <span class="n">cmd</span> <span class="o">+=</span> <span class="n">git_options</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">always_commit</span><span class="p">:</span>
            <span class="n">cmd</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;-c&#39;</span><span class="p">,</span> <span class="s1">&#39;annex.alwayscommit=false&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">merge_annex_branches</span><span class="p">:</span>
            <span class="n">cmd</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;-c&#39;</span><span class="p">,</span> <span class="s1">&#39;annex.merge-annex-branches=false&#39;</span><span class="p">]</span>

        <span class="c1"># annex portion of the command</span>
        <span class="n">cmd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;annex&#39;</span><span class="p">)</span>
        <span class="n">cmd</span> <span class="o">+=</span> <span class="n">args</span>

        <span class="k">if</span> <span class="n">lgr</span><span class="o">.</span><span class="n">getEffectiveLevel</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">:</span>
            <span class="n">cmd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;--debug&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annex_common_options</span><span class="p">:</span>
            <span class="n">cmd</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annex_common_options</span>

        <span class="k">if</span> <span class="n">jobs</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="c1"># Limit to # of CPUs (but at least 3 to start with)</span>
            <span class="c1"># and also an additional config constraint (by default 1</span>
            <span class="c1"># due to https://github.com/datalad/datalad/issues/4404)</span>
            <span class="n">jobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_auto_jobs</span> <span class="ow">or</span> <span class="nb">min</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">obtain</span><span class="p">(</span><span class="s1">&#39;datalad.runtime.max-annex-jobs&#39;</span><span class="p">),</span>
                <span class="nb">max</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">cpu_count</span><span class="p">()))</span>
            <span class="c1"># cache result to avoid repeated calls to cpu_count()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_auto_jobs</span> <span class="o">=</span> <span class="n">jobs</span>
        <span class="k">if</span> <span class="n">jobs</span> <span class="ow">and</span> <span class="n">jobs</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cmd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;-J</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">jobs</span><span class="p">)</span>

        <span class="n">runner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_git_runner</span>
        <span class="n">env</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fake_dates_enabled</span><span class="p">:</span>
            <span class="n">env</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_fake_dates</span><span class="p">(</span><span class="n">runner</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">files</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">protocol</span><span class="p">,</span> <span class="n">GeneratorMixIn</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">runner</span><span class="o">.</span><span class="n">run_on_filelist_chunks_items_</span><span class="p">(</span>
                        <span class="n">cmd</span><span class="p">,</span>
                        <span class="n">files</span><span class="p">,</span>
                        <span class="n">protocol</span><span class="o">=</span><span class="n">protocol</span><span class="p">,</span>
                        <span class="n">env</span><span class="o">=</span><span class="n">env</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">runner</span><span class="o">.</span><span class="n">run_on_filelist_chunks</span><span class="p">(</span>
                        <span class="n">cmd</span><span class="p">,</span>
                        <span class="n">files</span><span class="p">,</span>
                        <span class="n">protocol</span><span class="o">=</span><span class="n">protocol</span><span class="p">,</span>
                        <span class="n">env</span><span class="o">=</span><span class="n">env</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">runner</span><span class="o">.</span><span class="n">run</span><span class="p">(</span>
                    <span class="n">cmd</span><span class="p">,</span>
                    <span class="n">stdin</span><span class="o">=</span><span class="n">stdin</span><span class="p">,</span>
                    <span class="n">protocol</span><span class="o">=</span><span class="n">protocol</span><span class="p">,</span>
                    <span class="n">env</span><span class="o">=</span><span class="n">env</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">CommandError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Note: A call might result in several &#39;failures&#39;, that can be or</span>
            <span class="c1"># cannot be handled here. Detection of something, we can deal with,</span>
            <span class="c1"># doesn&#39;t mean there&#39;s nothing else to deal with.</span>

            <span class="c1"># OutOfSpaceError:</span>
            <span class="c1"># Note:</span>
            <span class="c1"># doesn&#39;t depend on anything in stdout. Therefore check this before</span>
            <span class="c1"># dealing with stdout</span>
            <span class="n">out_of_space_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span>
                <span class="s2">&quot;not enough free space, need (.*) more&quot;</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">stderr</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">out_of_space_re</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">OutOfSpaceError</span><span class="p">(</span><span class="n">cmd</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;annex&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">args</span><span class="p">,</span>
                                      <span class="n">sizemore_msg</span><span class="o">=</span><span class="n">out_of_space_re</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># RemoteNotAvailableError:</span>
            <span class="n">remote_na_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span>
                <span class="s2">&quot;there is no available git remote named </span><span class="se">\&quot;</span><span class="s2">(.*)</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">stderr</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">remote_na_re</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">RemoteNotAvailableError</span><span class="p">(</span><span class="n">cmd</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;annex&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">args</span><span class="p">,</span>
                                              <span class="n">remote</span><span class="o">=</span><span class="n">remote_na_re</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># TEMP: Workaround for git-annex bug, where it reports success=True</span>
            <span class="c1"># for annex add, while simultaneously complaining, that it is in</span>
            <span class="c1"># a submodule:</span>
            <span class="c1"># TODO: For now just reraise. But independently on this bug, it</span>
            <span class="c1"># makes sense to have an exception for that case</span>
            <span class="n">in_subm_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span>
                <span class="s2">&quot;fatal: Pathspec &#39;(.*)&#39; is in submodule &#39;(.*)&#39;&quot;</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">stderr</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">in_subm_re</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">e</span>

            <span class="c1"># we don&#39;t know how to handle this, just pass it on</span>
            <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">_call_annex_records</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">git_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">stdin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">merge_annex_branches</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal helper to run git-annex commands with JSON result processing</span>

<span class="sd">        `_call_annex()` is used for git-annex command execution, using</span>
<span class="sd">        AnnexJsonProtocol.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args: list</span>
<span class="sd">          See `_call_annex()` for details.</span>
<span class="sd">        files: list, optional</span>
<span class="sd">          See `_call_annex()` for details.</span>
<span class="sd">        jobs : int or &#39;auto&#39;, optional</span>
<span class="sd">          See `_call_annex()` for details.</span>
<span class="sd">        git_options: list, optional</span>
<span class="sd">          See `_call_annex()` for details.</span>
<span class="sd">        stdin: File-like, optional</span>
<span class="sd">          See `_call_annex()` for details.</span>
<span class="sd">        merge_annex_branches: bool, optional</span>
<span class="sd">          See `_call_annex()` for details.</span>
<span class="sd">        **kwargs:</span>
<span class="sd">          Additional arguments are passed on to the AnnexJsonProtocol constructor</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list(dict)</span>
<span class="sd">          List of parsed result records.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        CommandError</span>
<span class="sd">          See `_call_annex()` for details.</span>
<span class="sd">        OutOfSpaceError</span>
<span class="sd">          See `_call_annex()` for details.</span>
<span class="sd">        RemoteNotAvailableError</span>
<span class="sd">          See `_call_annex()` for details.</span>
<span class="sd">        RuntimeError</span>
<span class="sd">          Output from the git-annex process was captured, but no structured</span>
<span class="sd">          records could be parsed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">protocol</span> <span class="o">=</span> <span class="n">AnnexJsonProtocol</span>

        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;--json&#39;</span><span class="p">,</span> <span class="s1">&#39;--json-error-messages&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">progress</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;--json-progress&#39;</span><span class="p">]</span>

        <span class="n">out</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_annex</span><span class="p">(</span>
                <span class="n">args</span><span class="p">,</span>
                <span class="n">files</span><span class="o">=</span><span class="n">files</span><span class="p">,</span>
                <span class="n">jobs</span><span class="o">=</span><span class="n">jobs</span><span class="p">,</span>
                <span class="n">protocol</span><span class="o">=</span><span class="n">protocol</span><span class="p">,</span>
                <span class="n">git_options</span><span class="o">=</span><span class="n">git_options</span><span class="p">,</span>
                <span class="n">stdin</span><span class="o">=</span><span class="n">stdin</span><span class="p">,</span>
                <span class="n">merge_annex_branches</span><span class="o">=</span><span class="n">merge_annex_branches</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="n">CommandError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Note: Workaround for not existing files as long as annex doesn&#39;t</span>
            <span class="c1"># report it within JSON response:</span>
            <span class="c1"># see http://git-annex.branchable.com/bugs/copy_does_not_reflect_some_failed_copies_in_--json_output/</span>
            <span class="n">not_existing</span> <span class="o">=</span> <span class="p">[</span>
                <span class="c1"># cut the file path from the middle, no useful delimiter</span>
                <span class="c1"># need to deal with spaces too!</span>
                <span class="n">line</span><span class="p">[</span><span class="mi">11</span><span class="p">:</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;git-annex:&#39;</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">line</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39; not found&#39;</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">not_existing</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># we create the error reporting herein. If all files were</span>
                    <span class="c1"># not found, there is nothing on stdout and we don&#39;t need</span>
                    <span class="c1"># anything</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;stdout_json&#39;</span><span class="p">:</span> <span class="p">[]}</span>
                <span class="n">out</span><span class="p">[</span><span class="s1">&#39;stdout_json&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;command&quot;</span><span class="p">:</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="s2">&quot;file&quot;</span><span class="p">:</span> <span class="n">f</span><span class="p">,</span>
                        <span class="s2">&quot;note&quot;</span><span class="p">:</span> <span class="s2">&quot;not found&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;success&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="p">}</span>
                    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">not_existing</span>
                <span class="p">)</span>

            <span class="c1"># Note: insert additional code here to analyse failure and possibly</span>
            <span class="c1"># raise a custom exception</span>

            <span class="c1"># if we didn&#39;t raise before, just depend on whether or not we seem</span>
            <span class="c1"># to have some json to return. It should contain information on</span>
            <span class="c1"># failure in keys &#39;success&#39; and &#39;note&#39;</span>
            <span class="c1"># TODO: This is not entirely true. &#39;annex status&#39; may return empty,</span>
            <span class="c1"># while there was a &#39;fatal:...&#39; in stderr, which should be a</span>
            <span class="c1"># failure/exception</span>
            <span class="c1"># Or if we had empty stdout but there was stderr</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">out</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">stderr</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">e</span>

            <span class="n">records</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;stdout_json&#39;</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">if</span> <span class="n">records</span><span class="p">:</span>
                <span class="n">have</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;stdout_json&#39;</span><span class="p">,</span> <span class="p">[])</span>
                <span class="n">have</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">records</span><span class="p">)</span>
                <span class="n">out</span><span class="p">[</span><span class="s1">&#39;stdout_json&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">have</span>

            <span class="c1">#if e.stderr:</span>
            <span class="c1">#    # else just warn about present errors</span>
            <span class="c1">#    shorten = lambda x: x[:1000] + &#39;...&#39; if len(x) &gt; 1000 else x</span>

            <span class="c1">#    _log = lgr.debug if kwargs.get(&#39;expect_fail&#39;, False) else lgr.warning</span>
            <span class="c1">#    _log(</span>
            <span class="c1">#        &quot;Running %s resulted in stderr output: %s&quot;,</span>
            <span class="c1">#        args, shorten(e.stderr)</span>
            <span class="c1">#    )</span>

        <span class="n">json_objects</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;stdout_json&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;stdout&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">json_objects</span><span class="p">:</span>
                <span class="c1"># We at least received some valid json output, so warn about</span>
                <span class="c1"># non-json output and continue.</span>
                <span class="n">lgr</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Received non-json lines for --json command: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="n">out</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Received no json output for --json command, only:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>

        <span class="c1"># A special remote might send a message via &quot;info&quot;. This is supposed</span>
        <span class="c1"># to be printed by annex but in case of</span>
        <span class="c1"># `--json` is returned by annex as &quot;{&#39;info&#39;: &#39;&lt;message&gt;&#39;}&quot;. See</span>
        <span class="c1"># https://git-annex.branchable.com/design/external_special_remote_protocol/#index5h2</span>
        <span class="c1">#</span>
        <span class="c1"># So, Ben thinks we should just spit it out here, since everything</span>
        <span class="c1"># calling _call_annex_records is concerned with the actual results</span>
        <span class="c1"># being returned. Moreover, this kind of response is special to</span>
        <span class="c1"># particular special remotes rather than particular annex commands.</span>
        <span class="c1"># So, likely there&#39;s nothing callers could do about it other than</span>
        <span class="c1"># spitting it out.</span>
        <span class="n">return_objects</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">json_objects</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">]:</span>
                <span class="n">lgr</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">return_objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">return_objects</span>

<div class="viewcode-block" id="AnnexRepo.call_annex_records"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.call_annex_records">[docs]</a>    <span class="k">def</span> <span class="nf">call_annex_records</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Call annex with `--json*` to request structured result records</span>

<span class="sd">        This method behaves like `call_annex()`, but returns parsed result</span>
<span class="sd">        records.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args : list of str</span>
<span class="sd">          Arguments to pass to `annex`.</span>
<span class="sd">        files : list of str, optional</span>
<span class="sd">          File arguments to pass to `annex`. The advantage of passing these here</span>
<span class="sd">          rather than as part of `args` is that the call will be split into</span>
<span class="sd">          multiple calls to avoid exceeding the maximum command line length.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list(dict)</span>
<span class="sd">          List of parsed result records.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        CommandError if the call exits with a non-zero status. All result</span>
<span class="sd">        records captured until the non-zero exit are available in the</span>
<span class="sd">        exception&#39;s `kwargs`-dict attribute under key &#39;stdout_json&#39;.</span>

<span class="sd">        See `_call_annex()` for more information on Exceptions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_annex_records</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="n">files</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnexRepo.call_annex"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.call_annex">[docs]</a>    <span class="k">def</span> <span class="nf">call_annex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Call annex and return standard output.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args : list of str</span>
<span class="sd">          Arguments to pass to `annex`.</span>
<span class="sd">        files : list of str, optional</span>
<span class="sd">          File arguments to pass to `annex`. The advantage of passing these here</span>
<span class="sd">          rather than as part of `args` is that the call will be split into</span>
<span class="sd">          multiple calls to avoid exceeding the maximum command line length.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        standard output (str)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        See `_call_annex()` for information on Exceptions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_annex</span><span class="p">(</span>
            <span class="n">args</span><span class="p">,</span>
            <span class="n">files</span><span class="o">=</span><span class="n">files</span><span class="p">,</span>
            <span class="n">protocol</span><span class="o">=</span><span class="n">StdOutErrCapture</span><span class="p">)[</span><span class="s1">&#39;stdout&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="AnnexRepo.call_annex_items_"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.call_annex_items_">[docs]</a>    <span class="k">def</span> <span class="nf">call_annex_items_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Call git-annex, splitting output on `sep`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args : list of str</span>
<span class="sd">          Arguments to pass to `git-annex`.</span>
<span class="sd">        files : list of str, optional</span>
<span class="sd">          File arguments to pass to `annex`. The advantage of passing these here</span>
<span class="sd">          rather than as part of `args` is that the call will be split into</span>
<span class="sd">          multiple calls to avoid exceeding the maximum command line length.</span>
<span class="sd">        sep : str, optional</span>
<span class="sd">          Split the output by `str.split(sep)` rather than `str.splitlines`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Generator that yields output items.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        See `_call_annex()` for information on Exceptions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">class</span> <span class="nc">GeneratorStdOutErrCapture</span><span class="p">(</span><span class="n">GeneratorMixIn</span><span class="p">,</span> <span class="n">StdOutErrCapture</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">GeneratorMixIn</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">StdOutErrCapture</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">pipe_data_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">fd</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">send_result</span><span class="p">((</span><span class="s2">&quot;stdout&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">)))</span>
                    <span class="k">return</span>
                <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">pipe_data_received</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

        <span class="n">line_splitter</span> <span class="o">=</span> <span class="n">LineSplitter</span><span class="p">(</span><span class="n">separator</span><span class="o">=</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">content</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_annex</span><span class="p">(</span>
                                <span class="n">args</span><span class="p">,</span>
                                <span class="n">files</span><span class="o">=</span><span class="n">files</span><span class="p">,</span>
                                <span class="n">protocol</span><span class="o">=</span><span class="n">GeneratorStdOutErrCapture</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="s2">&quot;stdout&quot;</span><span class="p">:</span>
                <span class="k">yield from</span> <span class="n">line_splitter</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>

        <span class="n">remaining_content</span> <span class="o">=</span> <span class="n">line_splitter</span><span class="o">.</span><span class="n">finish_processing</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">remaining_content</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">remaining_content</span></div>

<div class="viewcode-block" id="AnnexRepo.call_annex_oneline"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.call_annex_oneline">[docs]</a>    <span class="k">def</span> <span class="nf">call_annex_oneline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Call annex for a single line of output.</span>

<span class="sd">        This method filters prior output line selection to exclude git-annex</span>
<span class="sd">        status output that is triggered by command execution, but is not</span>
<span class="sd">        related to the particular command. This includes lines like:</span>

<span class="sd">          (merging ... into git-annex)</span>
<span class="sd">          (recording state ...)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args : list of str</span>
<span class="sd">          Arguments to pass to `annex`.</span>
<span class="sd">        files : list of str, optional</span>
<span class="sd">          File arguments to pass to `annex`. The advantage of passing these here</span>
<span class="sd">          rather than as part of `args` is that the call will be split into</span>
<span class="sd">          multiple calls to avoid exceeding the maximum command line length.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">          Either a single output line, or an empty string if there was no</span>
<span class="sd">          output.</span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AssertionError if there is more than one line of output.</span>

<span class="sd">        See `_call_annex()` for information on Exceptions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ignore some lines</span>
        <span class="c1"># see https://git-annex.branchable.com/todo/output_of_wanted___40__and_possibly_group_etc__41___should_not_be_polluted_with___34__informational__34___messages/</span>
        <span class="c1"># that links claims it is fixed, but &#39;(recording state in git...)&#39;</span>
        <span class="c1"># still appear as of 8.20201103-1</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_annex_items_</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="n">files</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">l</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span>
                <span class="sa">r</span><span class="s1">&#39;\((merging .* into git-annex|recording state ).*\.\.\.\)&#39;</span><span class="p">,</span> <span class="n">l</span>
            <span class="p">)</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="s2">&quot;Expected </span><span class="si">{}</span><span class="s2"> to return single line, but it returned </span><span class="si">{}</span><span class="s2">&quot;</span>
                <span class="o">.</span><span class="n">format</span><span class="p">([</span><span class="s2">&quot;git&quot;</span><span class="p">,</span> <span class="s1">&#39;annex&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">args</span><span class="p">,</span> <span class="n">lines</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">lines</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span></div>

    <span class="k">def</span> <span class="nf">_is_direct_mode_from_config</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Figure out if in direct mode from the git config.</span>

<span class="sd">        Since relies on reading config, expensive to be used often</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        True if in direct mode, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If .git/config lacks an entry &quot;direct&quot;,</span>
        <span class="c1"># it&#39;s actually indirect mode.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">reload</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">getbool</span><span class="p">(</span><span class="s2">&quot;annex&quot;</span><span class="p">,</span> <span class="s2">&quot;direct&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="AnnexRepo.is_direct_mode"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.is_direct_mode">[docs]</a>    <span class="k">def</span> <span class="nf">is_direct_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if annex is in direct mode</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        True if in direct mode, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_direct_mode</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_direct_mode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># we need to figure it out</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_direct_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_direct_mode_from_config</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_direct_mode</span></div>

<div class="viewcode-block" id="AnnexRepo.is_crippled_fs"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.is_crippled_fs">[docs]</a>    <span class="k">def</span> <span class="nf">is_crippled_fs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if git-annex considers current filesystem &#39;crippled&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        True if on crippled filesystem, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">reload</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">getbool</span><span class="p">(</span><span class="s2">&quot;annex&quot;</span><span class="p">,</span> <span class="s2">&quot;crippledfilesystem&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">supports_unlocked_pointers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if repository version supports unlocked pointers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">getint</span><span class="p">(</span><span class="s2">&quot;annex&quot;</span><span class="p">,</span> <span class="s2">&quot;version&quot;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">6</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># If annex.version isn&#39;t set (e.g., an uninitialized repo), assume</span>
            <span class="c1"># that unlocked pointers are supported given that they are with the</span>
            <span class="c1"># minimum git-annex version.</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initializes an annex repository.</span>

<span class="sd">        Note: This is intended for private use in this class by now.</span>
<span class="sd">        If you have an object of this class already,</span>
<span class="sd">        there shouldn&#39;t be a need to &#39;init&#39; again.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># MIH: this function is required for re-initing repos. The logic</span>
        <span class="c1"># in the constructor is rather convoluted and doesn&#39;t acknowledge</span>
        <span class="c1"># the case of a perfectly healthy annex that just needs a new</span>
        <span class="c1"># description</span>
        <span class="c1"># will keep leading underscore in the name for know, but this is</span>
        <span class="c1"># not private</span>
        <span class="c1"># TODO: provide git and git-annex options.</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">description</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">opts</span> <span class="o">+=</span> <span class="p">[</span><span class="n">description</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">version</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">upgraded_version</span> <span class="o">=</span> <span class="n">_AUTO_UPGRADEABLE_VERSIONS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">version</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">upgraded_version</span><span class="p">:</span>
                <span class="n">lgr</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Annex repository version </span><span class="si">%s</span><span class="s2"> will be upgraded to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                         <span class="n">version</span><span class="p">,</span> <span class="n">upgraded_version</span><span class="p">)</span>
            <span class="n">opts</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;--version&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">version</span><span class="p">)]</span>

        <span class="c1"># TODO: RM DIRECT?  or RF at least ?</span>
        <span class="c1"># Note: git-annex-init kills a possible tracking branch for</span>
        <span class="c1"># &#39;annex/direct/my_branch&#39;, if we just cloned from a repo in direct</span>
        <span class="c1"># mode. We want to preserve the information about the tracking branch,</span>
        <span class="c1"># as if the source repo wasn&#39;t in direct mode.</span>
        <span class="c1"># Note 2: Actually we do it for all &#39;managed branches&#39;. This might turn</span>
        <span class="c1"># out to not be necessary</span>
        <span class="n">sections_to_preserve</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;branch.</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">branch</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_branches</span><span class="p">()</span>
                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_managed_branch</span><span class="p">(</span><span class="n">branch</span><span class="p">)</span>
                                <span class="ow">and</span> <span class="s2">&quot;branch.</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">branch</span><span class="p">)</span> <span class="ow">in</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">sections</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">sct</span> <span class="ow">in</span> <span class="n">sections_to_preserve</span><span class="p">:</span>
            <span class="n">orig_branch</span> <span class="o">=</span> <span class="n">sct</span><span class="p">[</span><span class="mi">7</span><span class="p">:]</span>
            <span class="n">new_branch</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">get_corresponding_branch</span><span class="p">(</span><span class="n">orig_branch</span><span class="p">)</span> <span class="ow">or</span> <span class="n">orig_branch</span>
            <span class="n">new_section</span> <span class="o">=</span> <span class="s2">&quot;branch.</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">new_branch</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">opt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">sct</span><span class="p">):</span>
                <span class="n">orig_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">sct</span><span class="p">,</span> <span class="n">opt</span><span class="p">)</span>
                <span class="n">new_value</span> <span class="o">=</span> <span class="n">orig_value</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">orig_branch</span><span class="p">,</span> <span class="n">new_branch</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">new_section</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">opt</span><span class="p">,</span>
                                <span class="n">value</span><span class="o">=</span><span class="n">new_value</span><span class="p">,</span>
                                <span class="n">where</span><span class="o">=</span><span class="s1">&#39;local&#39;</span><span class="p">,</span>
                                <span class="n">reload</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call_annex</span><span class="p">([</span><span class="s1">&#39;init&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">opts</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">AnnexInitOutput</span><span class="p">)</span>
        <span class="c1"># TODO: When to expect stderr?</span>
        <span class="c1"># on crippled filesystem for example (think so)?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">reload</span><span class="p">()</span>

<div class="viewcode-block" id="AnnexRepo.get"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.get">[docs]</a>    <span class="nd">@normalize_paths</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">remote</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the actual content of files</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        files : list of str</span>
<span class="sd">            paths to get</span>
<span class="sd">        remote : str, optional</span>
<span class="sd">            from which remote to fetch content</span>
<span class="sd">        options : list of str, optional</span>
<span class="sd">            commandline options for the git annex get command</span>
<span class="sd">        jobs : int or None, optional</span>
<span class="sd">            how many jobs to run in parallel (passed to git-annex call).</span>
<span class="sd">            If not specified (None), then</span>
<span class="sd">        key : bool, optional</span>
<span class="sd">            If provided file value is actually a key</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        files : list of dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">options</span> <span class="o">=</span> <span class="n">options</span><span class="p">[:]</span> <span class="k">if</span> <span class="n">options</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;annex.retry&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">[</span><span class="s2">&quot;-c&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;annex.retry=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">obtain</span><span class="p">(</span><span class="s2">&quot;datalad.annex.retry&quot;</span><span class="p">))])</span>

        <span class="k">if</span> <span class="n">remote</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">remote</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_remotes</span><span class="p">():</span>
                <span class="k">raise</span> <span class="n">RemoteNotAvailableError</span><span class="p">(</span>
                    <span class="n">remote</span><span class="o">=</span><span class="n">remote</span><span class="p">,</span>
                    <span class="n">cmd</span><span class="o">=</span><span class="s2">&quot;annex get&quot;</span><span class="p">,</span>
                    <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Remote is not known. Known are: </span><span class="si">%s</span><span class="s2">&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_remotes</span><span class="p">(),)</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_open_ssh_connection</span><span class="p">(</span><span class="n">remote</span><span class="p">)</span>
            <span class="n">options</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;--from&#39;</span><span class="p">,</span> <span class="n">remote</span><span class="p">]</span>

        <span class="c1"># analyze provided files to decide which actually are needed to be</span>
        <span class="c1"># fetched</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span><span class="p">:</span>
            <span class="n">expected_downloads</span><span class="p">,</span> <span class="n">fetch_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_expected_files</span><span class="p">(</span>
                <span class="n">files</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;--not&#39;</span><span class="p">,</span> <span class="s1">&#39;--in&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">],</span>
                <span class="n">merge_annex_branches</span><span class="o">=</span><span class="kc">False</span>  <span class="c1"># interested only in local info</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fetch_files</span> <span class="o">=</span> <span class="n">files</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;When key=True only a single file be provided&quot;</span>
            <span class="n">expected_downloads</span> <span class="o">=</span> <span class="p">{</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">AnnexRepo</span><span class="o">.</span><span class="n">get_size_from_key</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">])}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fetch_files</span><span class="p">:</span>
            <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;No files found needing fetching.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fetch_files</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">):</span>
            <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Actually getting </span><span class="si">%d</span><span class="s2"> files&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fetch_files</span><span class="p">))</span>

        <span class="c1"># TODO: provide more meaningful message (possibly aggregating &#39;note&#39;</span>
        <span class="c1">#  from annex failed ones</span>
        <span class="c1"># TODO: reproduce DK&#39;s bug on OSX, and either switch to</span>
        <span class="c1">#  --batch mode (I don&#39;t think we have --progress support in long</span>
        <span class="c1">#  alive batch processes ATM),</span>
        <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
            <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;get&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">options</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;--key&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">files</span>
            <span class="n">files_arg</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;get&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">options</span>
            <span class="n">files_arg</span> <span class="o">=</span> <span class="n">files</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_annex_records</span><span class="p">(</span>
            <span class="n">cmd</span><span class="p">,</span>
            <span class="c1"># TODO: eventually make use of --batch mode</span>
            <span class="n">files</span><span class="o">=</span><span class="n">files_arg</span><span class="p">,</span>
            <span class="n">jobs</span><span class="o">=</span><span class="n">jobs</span><span class="p">,</span>
            <span class="n">progress</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="c1"># filter(bool,   to avoid trying to add up None&#39;s when size is not known</span>
            <span class="n">total_nbytes</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">expected_downloads</span><span class="o">.</span><span class="n">values</span><span class="p">())),</span>
        <span class="p">)</span>
        <span class="n">results_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="c1"># TODO:  should we here compare fetch_files against result_list</span>
        <span class="c1"># and vomit an exception of incomplete download????</span>
        <span class="k">return</span> <span class="n">results_list</span></div>

    <span class="k">def</span> <span class="nf">_get_expected_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">merge_annex_branches</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a list of files, figure out what to be downloaded</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        files</span>
<span class="sd">        expr: list</span>
<span class="sd">          Expression to be passed into annex&#39;s find</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        expected_files : dict</span>
<span class="sd">          key -&gt; size</span>
<span class="sd">        fetch_files : list</span>
<span class="sd">          files to be fetched</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Determine what files match the query to work with&quot;</span><span class="p">)</span>
        <span class="c1"># Let&#39;s figure out first which files/keys and of what size to download</span>
        <span class="n">expected_files</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">fetch_files</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">keys_seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">unknown_sizes</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># unused atm</span>
        <span class="c1"># for now just record total size, and</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_annex_records</span><span class="p">(</span>
                <span class="p">[</span><span class="s1">&#39;find&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">expr</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="n">files</span><span class="p">,</span>
                <span class="n">merge_annex_branches</span><span class="o">=</span><span class="n">merge_annex_branches</span>
        <span class="p">):</span>
            <span class="c1"># TODO: some files might not even be here.  So in current fancy</span>
            <span class="c1"># output reporting scheme we should then theoretically handle</span>
            <span class="c1"># those cases here and say &#39;impossible&#39; or something like that</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;success&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
                <span class="c1"># TODO: I guess do something with yielding and filtering for</span>
                <span class="c1"># what need to be done and what not</span>
                <span class="k">continue</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bytesize&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys_seen</span><span class="p">:</span>
                <span class="c1"># multiple files could point to the same key.  no need to</span>
                <span class="c1"># request multiple times</span>
                <span class="k">continue</span>
            <span class="n">keys_seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">j</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span>
            <span class="n">fetch_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">size</span> <span class="ow">and</span> <span class="n">size</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                <span class="n">expected_files</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expected_files</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">unknown_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">expected_files</span><span class="p">,</span> <span class="n">fetch_files</span>

<div class="viewcode-block" id="AnnexRepo.add"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.add">[docs]</a>    <span class="nd">@normalize_paths</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">git</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">git_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">annex_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add file(s) to the repository.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        files: list of str</span>
<span class="sd">          list of paths to add to the annex</span>
<span class="sd">        git: bool</span>
<span class="sd">          if True, add to git instead of annex.</span>
<span class="sd">        backend:</span>
<span class="sd">        options:</span>
<span class="sd">        update: bool</span>
<span class="sd">          --update option for git-add. From git&#39;s manpage:</span>
<span class="sd">           Update the index just where it already has an entry matching</span>
<span class="sd">           &lt;pathspec&gt;. This removes as well as modifies index entries to match</span>
<span class="sd">           the working tree, but adds no new files.</span>

<span class="sd">           If no &lt;pathspec&gt; is given when --update option is used, all tracked</span>
<span class="sd">           files in the entire working tree are updated (old versions of Git</span>
<span class="sd">           used to limit the update to the current directory and its</span>
<span class="sd">           subdirectories).</span>

<span class="sd">           Note: Used only, if a call to git-add instead of git-annex-add is</span>
<span class="sd">           performed</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of dict or dict</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">add_</span><span class="p">(</span>
            <span class="n">files</span><span class="p">,</span> <span class="n">git</span><span class="o">=</span><span class="n">git</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span> <span class="n">jobs</span><span class="o">=</span><span class="n">jobs</span><span class="p">,</span>
            <span class="n">git_options</span><span class="o">=</span><span class="n">git_options</span><span class="p">,</span> <span class="n">annex_options</span><span class="o">=</span><span class="n">annex_options</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="n">update</span>
        <span class="p">))</span></div>

<div class="viewcode-block" id="AnnexRepo.add_"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.add_">[docs]</a>    <span class="k">def</span> <span class="nf">add_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">git</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">git_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">annex_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Like `add`, but returns a generator&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">update</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">git</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InsufficientArgumentsError</span><span class="p">(</span><span class="s2">&quot;option &#39;update&#39; requires &#39;git&#39;, too&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">git_options</span><span class="p">:</span>
            <span class="c1"># TODO: note that below we would use &#39;add with --dry-run</span>
            <span class="c1"># so passed here options might need to be passed into it??</span>
            <span class="n">lgr</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;add: git_options not yet implemented. Ignored.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">annex_options</span><span class="p">:</span>
            <span class="n">lgr</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;annex_options not yet implemented. Ignored.&quot;</span><span class="p">)</span>

        <span class="n">options</span> <span class="o">=</span> <span class="n">options</span><span class="p">[:]</span> <span class="k">if</span> <span class="n">options</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="c1"># TODO: RM DIRECT? not clear if this code didn&#39;t become &quot;generic&quot; and</span>
        <span class="c1">#       not only &quot;direct mode&quot; specific, so kept for now.</span>
        <span class="c1"># Note: As long as we support direct mode, one should not call</span>
        <span class="c1"># super().add() directly. Once direct mode is gone, we might remove</span>
        <span class="c1"># `git` parameter and call GitRepo&#39;s add() instead.</span>

        <span class="k">def</span> <span class="nf">_get_to_be_added_recs</span><span class="p">(</span><span class="n">paths</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Try to collect what actually is going to be added</span>

<span class="sd">            This is used for progress information</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># TODO: RM DIRECT? might remain useful to detect submods left in direct mode</span>
            <span class="c1"># Note: if a path involves a submodule in direct mode, while we</span>
            <span class="c1"># are not in direct mode at current level, we might still fail.</span>
            <span class="c1"># Hence the except clause is still needed. However, this is</span>
            <span class="c1"># unlikely, since direct mode usually should be used only, if it</span>
            <span class="c1"># was enforced by FS and/or OS and therefore concerns the entire</span>
            <span class="c1"># hierarchy.</span>
            <span class="n">_git_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;--dry-run&#39;</span><span class="p">,</span> <span class="s1">&#39;-N&#39;</span><span class="p">,</span> <span class="s1">&#39;--ignore-missing&#39;</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">super</span><span class="p">(</span><span class="n">AnnexRepo</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_</span><span class="p">(</span>
                        <span class="n">files</span><span class="p">,</span> <span class="n">git_options</span><span class="o">=</span><span class="n">_git_options</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="n">update</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">r</span>
                    <span class="k">return</span>
            <span class="k">except</span> <span class="n">CommandError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">ce</span> <span class="o">=</span> <span class="n">CapturedException</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="c1"># TODO: RM DIRECT?  left for detection of direct mode submodules</span>
                <span class="k">if</span> <span class="n">AnnexRepo</span><span class="o">.</span><span class="n">_is_annex_work_tree_message</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">stderr</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">DirectModeNoLongerSupportedError</span><span class="p">(</span>
                        <span class="bp">self</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
                <span class="k">raise</span>

        <span class="c1"># Theoretically we could have done for git as well, if it could have</span>
        <span class="c1"># been batched</span>
        <span class="c1"># Call git annex add for any to have full control of whether to go</span>
        <span class="c1"># to git or to annex</span>
        <span class="c1"># 1. Figure out what actually will be added</span>
        <span class="n">to_be_added_recs</span> <span class="o">=</span> <span class="n">_get_to_be_added_recs</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
        <span class="c1"># collect their sizes for the progressbar</span>
        <span class="n">expected_additions</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">rec</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_file_size</span><span class="p">(</span><span class="n">rec</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">to_be_added_recs</span>
        <span class="p">}</span>

        <span class="c1"># if None -- leave it to annex to decide</span>
        <span class="k">if</span> <span class="n">git</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;--force-large&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">git</span><span class="p">:</span>
            <span class="c1"># explicitly use git-add with --update instead of git-annex-add</span>
            <span class="c1"># TODO: This might still need some work, when --update AND files</span>
            <span class="c1"># are specified!</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">super</span><span class="p">(</span><span class="n">AnnexRepo</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                    <span class="n">files</span><span class="p">,</span>
                    <span class="n">git</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">git_options</span><span class="o">=</span><span class="n">git_options</span><span class="p">,</span>
                    <span class="n">update</span><span class="o">=</span><span class="n">update</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">r</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">backend</span><span class="p">:</span>
                <span class="n">options</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="s1">&#39;--backend&#39;</span><span class="p">,</span> <span class="n">backend</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_annex_records</span><span class="p">(</span>
                    <span class="p">[</span><span class="s1">&#39;add&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">options</span><span class="p">,</span>
                    <span class="n">files</span><span class="o">=</span><span class="n">files</span><span class="p">,</span>
                    <span class="n">jobs</span><span class="o">=</span><span class="n">jobs</span><span class="p">,</span>
                    <span class="n">total_nbytes</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">expected_additions</span><span class="o">.</span><span class="n">values</span><span class="p">())):</span>
                <span class="k">yield</span> <span class="n">r</span></div>

<div class="viewcode-block" id="AnnexRepo.get_file_key"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.get_file_key">[docs]</a>    <span class="nd">@normalize_paths</span>
    <span class="k">def</span> <span class="nf">get_file_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;DEPRECATED. Use get_content_annexinfo()</span>

<span class="sd">        See the method body for how to use get_content_annexinfo() to</span>
<span class="sd">        replace get_file_key().</span>

<span class="sd">        For single-file queries it is recommended to consider</span>
<span class="sd">        get_file_annexinfo()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;AnnexRepo.get_file_key() is deprecated, &quot;</span>
            <span class="s2">&quot;use get_content_annexinfo() instead.&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">)</span>

        <span class="c1"># this is only needed, because a previous implementation wanted to</span>
        <span class="c1"># disect reasons for not being able to report a key: file not there,</span>
        <span class="c1"># file in git, but not annexed. If not for that, this could be</span>
        <span class="c1">#init = None</span>
        <span class="n">init</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pathobj</span> <span class="o">/</span> <span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">],</span>
                <span class="p">[{}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">))]</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_content_annexinfo</span><span class="p">(</span>
            <span class="n">files</span><span class="p">,</span>
            <span class="n">init</span><span class="o">=</span><span class="n">init</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">info</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>

        <span class="c1"># everything below is only needed to achieve compatibility with the</span>
        <span class="c1"># complex behavior of a previous implementation if not for that, we</span>
        <span class="c1"># could achieve uniform behavior regardless of input specifics with a</span>
        <span class="c1"># simple</span>
        <span class="c1">#return keys</span>

        <span class="k">if</span> <span class="n">batch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="s1">&#39;&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">not_found</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">p</span>
                <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">info</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;success&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;note&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;not found&#39;</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">not_found</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">FileNotInAnnexError</span><span class="p">(</span>
                    <span class="n">cmd</span><span class="o">=</span><span class="s1">&#39;find&#39;</span><span class="p">,</span>
                    <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;File not in annex: </span><span class="si">{</span><span class="n">not_found</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">filename</span><span class="o">=</span><span class="n">not_found</span><span class="p">)</span>

            <span class="n">no_annex</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">info</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">no_annex</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">FileInGitError</span><span class="p">(</span>
                    <span class="n">cmd</span><span class="o">=</span><span class="s1">&#39;find&#39;</span><span class="p">,</span>
                    <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;File not in annex, but git: </span><span class="si">{</span><span class="n">no_annex</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">filename</span><span class="o">=</span><span class="n">no_annex</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">batch</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">keys</span></div>

<div class="viewcode-block" id="AnnexRepo.unlock"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.unlock">[docs]</a>    <span class="nd">@normalize_paths</span>
    <span class="k">def</span> <span class="nf">unlock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;unlock files for modification</span>

<span class="sd">        Note: This method is silent about errors in unlocking a file (e.g, the</span>
<span class="sd">        file has not content). Use the higher-level interface.unlock to get</span>
<span class="sd">        more informative reporting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        files: list of str</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of str</span>
<span class="sd">          successfully unlocked files</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">files</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">call_annex_records</span><span class="p">([</span><span class="s2">&quot;unlock&quot;</span><span class="p">],</span> <span class="n">files</span><span class="o">=</span><span class="n">files</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">j</span><span class="p">[</span><span class="s2">&quot;success&quot;</span><span class="p">]]</span></div>

<div class="viewcode-block" id="AnnexRepo.adjust"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.adjust">[docs]</a>    <span class="k">def</span> <span class="nf">adjust</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;enter an adjusted branch</span>

<span class="sd">        This command is only available in a v6+ git-annex repository.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        options: list of str</span>
<span class="sd">          currently requires &#39;--unlock&#39; or &#39;--fix&#39;;</span>
<span class="sd">          default: --unlock</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Do we want to catch the case that</span>
        <span class="c1"># &quot;adjusted/&lt;current_branch_name&gt;(unlocked)&quot; already exists and</span>
        <span class="c1"># just check it out? Or fail like annex itself does?</span>

        <span class="c1"># version check:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">supports_unlocked_pointers</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CommandNotAvailableError</span><span class="p">(</span>
                <span class="n">cmd</span><span class="o">=</span><span class="s1">&#39;git annex adjust&#39;</span><span class="p">,</span>
                <span class="n">msg</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;git-annex-adjust requires a &#39;</span>
                     <span class="s1">&#39;version that supports unlocked pointers&#39;</span><span class="p">))</span>

        <span class="n">options</span> <span class="o">=</span> <span class="n">options</span><span class="p">[:]</span> <span class="k">if</span> <span class="n">options</span> <span class="k">else</span> <span class="n">to_options</span><span class="p">(</span><span class="n">unlock</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">call_annex</span><span class="p">([</span><span class="s1">&#39;adjust&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">options</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnexRepo.unannex"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.unannex">[docs]</a>    <span class="nd">@normalize_paths</span>
    <span class="k">def</span> <span class="nf">unannex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;undo accidental add command</span>

<span class="sd">        Use this to undo an accidental git annex add command. Note that for</span>
<span class="sd">        safety, the content of the file remains in the annex, until you use git</span>
<span class="sd">        annex unused and git annex dropunused.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        files: list of str</span>
<span class="sd">        options: list of str</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of str</span>
<span class="sd">          successfully unannexed files</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">options</span> <span class="o">=</span> <span class="n">options</span><span class="p">[:]</span> <span class="k">if</span> <span class="n">options</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="p">[</span>
            <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_annex_items_</span><span class="p">([</span><span class="s1">&#39;unannex&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">options</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="n">files</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;unannex&#39;</span> <span class="ow">and</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ok&#39;</span>
        <span class="p">]</span></div>

<div class="viewcode-block" id="AnnexRepo.find"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.find">[docs]</a>    <span class="nd">@normalize_paths</span><span class="p">(</span><span class="n">map_filenames_back</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run `git annex find` on file(s).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        files: list of str</span>
<span class="sd">            files to find under annex</span>
<span class="sd">        batch: bool, optional</span>
<span class="sd">            initiate or continue with a batched run of annex find, instead of just</span>
<span class="sd">            calling a single git annex find command. If any items in `files`</span>
<span class="sd">            are directories, this value is treated as False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A dictionary the maps each item in `files` to its `git annex find`</span>
<span class="sd">        result. Items without a successful result will be an empty string, and</span>
<span class="sd">        multi-item results (which can occur for if `files` includes a</span>
<span class="sd">        directory) will be returned as a list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">objects</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Ignore batch=True if any path is a directory because `git annex find</span>
        <span class="c1"># --batch` always returns an empty string for directories.</span>
        <span class="k">if</span> <span class="n">batch</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">isdir</span><span class="p">(</span><span class="n">opj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">):</span>
            <span class="n">find</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_batched</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s1">&#39;find&#39;</span><span class="p">,</span> <span class="n">json</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
                <span class="c1"># Since we are just interested in local information</span>
                <span class="n">git_options</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;-c&#39;</span><span class="p">,</span> <span class="s1">&#39;annex.merge-annex-branches=false&#39;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">objects</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">json_out</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">json_out</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">find</span><span class="p">(</span><span class="n">files</span><span class="p">))}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_annex</span><span class="p">(</span>
                        <span class="p">[</span><span class="s1">&#39;find&#39;</span><span class="p">,</span> <span class="s2">&quot;--print0&quot;</span><span class="p">],</span>
                        <span class="n">files</span><span class="o">=</span><span class="p">[</span><span class="n">f</span><span class="p">],</span>
                        <span class="n">merge_annex_branches</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">items</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;stdout&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\0</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\0</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">objects</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">items</span>
                <span class="k">except</span> <span class="n">CommandError</span><span class="p">:</span>
                    <span class="n">objects</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="k">return</span> <span class="n">objects</span></div>

    <span class="k">def</span> <span class="nf">_check_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">batch</span><span class="p">):</span>
        <span class="c1"># Helper that isolates the common logic in `file_has_content` and</span>
        <span class="c1"># `is_under_annex`. `fn` is the annex command used to do the check, and</span>
        <span class="c1"># `quick_fn` is the non-annex variant.</span>
        <span class="n">pointers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">supports_unlocked_pointers</span>
        <span class="c1"># We&#39;re only concerned about modified files in V6+ mode. In V5</span>
        <span class="c1"># `find` returns an empty string for unlocked files.</span>
        <span class="c1">#</span>
        <span class="c1"># ATTN: test_AnnexRepo_file_has_content has a failure before Git</span>
        <span class="c1"># v2.13 (tested back to v2.9) because this diff call unexpectedly</span>
        <span class="c1"># reports a type change as modified.</span>
        <span class="n">modified</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_git_items_</span><span class="p">(</span>
                <span class="p">[</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;--name-only&#39;</span><span class="p">,</span> <span class="s1">&#39;-z&#39;</span><span class="p">],</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">f</span><span class="p">]</span> <span class="k">if</span> <span class="n">pointers</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="n">annex_res</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">normalize_paths</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="n">batch</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">bool</span><span class="p">(</span><span class="n">annex_res</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">and</span>
                     <span class="ow">not</span> <span class="p">(</span><span class="n">pointers</span> <span class="ow">and</span> <span class="n">normpath</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="n">modified</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">]</span>

<div class="viewcode-block" id="AnnexRepo.file_has_content"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.file_has_content">[docs]</a>    <span class="nd">@normalize_paths</span>
    <span class="k">def</span> <span class="nf">file_has_content</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">allow_quick</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether files have their content present under annex.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        files: list of str</span>
<span class="sd">            file(s) to check for being actually present.</span>
<span class="sd">        allow_quick: bool, optional</span>
<span class="sd">            This is no longer supported.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of bool</span>
<span class="sd">            For each input file states whether file has content locally</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Also provide option to look for key instead of path</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_files</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">batch</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnexRepo.is_under_annex"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.is_under_annex">[docs]</a>    <span class="nd">@normalize_paths</span>
    <span class="k">def</span> <span class="nf">is_under_annex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">allow_quick</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether files are under annex control</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        files: list of str</span>
<span class="sd">            file(s) to check for being under annex</span>
<span class="sd">        allow_quick: bool, optional</span>
<span class="sd">            This is no longer supported.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of bool</span>
<span class="sd">            For each input file states whether file is under annex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># theoretically in direct mode files without content would also be</span>
        <span class="c1"># broken symlinks on the FSs which support it, but that would complicate</span>
        <span class="c1"># the matters</span>

        <span class="c1"># This is an ugly hack to prevent files from being treated as</span>
        <span class="c1"># remotes by `git annex info`. See annex&#39;s `nameToUUID&#39;`.</span>
        <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">opj</span><span class="p">(</span><span class="n">curdir</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># Filter out directories because it doesn&#39;t make sense to ask if</span>
            <span class="c1"># they are under annex control and `info` can only handle</span>
            <span class="c1"># non-directories.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">([</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">isdir</span><span class="p">(</span><span class="n">f</span><span class="p">)],</span>
                             <span class="n">fast</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_files</span><span class="p">(</span><span class="n">check</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">batch</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnexRepo.init_remote"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.init_remote">[docs]</a>    <span class="k">def</span> <span class="nf">init_remote</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a new special remote</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name: str</span>
<span class="sd">            name of the special remote</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: figure out consistent way for passing options + document</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">call_annex</span><span class="p">([</span><span class="s1">&#39;initremote&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">+</span> <span class="n">options</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">reload</span><span class="p">()</span></div>

<div class="viewcode-block" id="AnnexRepo.enable_remote"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.enable_remote">[docs]</a>    <span class="k">def</span> <span class="nf">enable_remote</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Enables use of an existing special remote</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name: str</span>
<span class="sd">            name, the special remote was created with</span>
<span class="sd">        options: list, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># MIH thinks there should be no `env` argument at all</span>
        <span class="c1"># https://github.com/datalad/datalad/issues/5162</span>
        <span class="n">env</span> <span class="o">=</span> <span class="n">env</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_git_runner</span><span class="o">.</span><span class="n">env</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">unittest.mock</span> <span class="kn">import</span> <span class="n">patch</span>
            <span class="k">with</span> <span class="n">patch</span><span class="o">.</span><span class="n">object</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_git_runner</span><span class="p">,</span> <span class="s1">&#39;env&#39;</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
                <span class="c1"># TODO: outputs are nohow used/displayed. Eventually convert to</span>
                <span class="c1"># to a generator style yielding our &quot;dict records&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">call_annex</span><span class="p">([</span><span class="s1">&#39;enableremote&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">]</span> <span class="o">+</span> <span class="n">ensure_list</span><span class="p">(</span><span class="n">options</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">CommandError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*StatusCodeException.*statusCode = 401&#39;</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">stderr</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">AccessDeniedError</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="s1">&#39;FailedConnectionException&#39;</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">stderr</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">AccessFailedError</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">e</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">reload</span><span class="p">()</span></div>

<div class="viewcode-block" id="AnnexRepo.merge_annex"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.merge_annex">[docs]</a>    <span class="k">def</span> <span class="nf">merge_annex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remote</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># do not use anymore, use localsync()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">localsync</span><span class="p">(</span><span class="n">remote</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnexRepo.sync"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.sync">[docs]</a>    <span class="k">def</span> <span class="nf">sync</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remotes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">push</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pull</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">commit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">content</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method is deprecated, use call_annex([&#39;sync&#39;, ...]) instead.</span>

<span class="sd">        Synchronize local repository with remotes</span>

<span class="sd">        Use  this  command  when you want to synchronize the local repository</span>
<span class="sd">        with one or more of its remotes. You can specify the remotes (or</span>
<span class="sd">        remote groups) to sync with by name; the default if none are specified</span>
<span class="sd">        is to sync with all remotes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        remotes: str, list(str), optional</span>
<span class="sd">          Name of one or more remotes to be sync&#39;ed.</span>
<span class="sd">        push : bool</span>
<span class="sd">          By default, git pushes to remotes.</span>
<span class="sd">        pull : bool</span>
<span class="sd">          By default, git pulls from remotes</span>
<span class="sd">        commit : bool</span>
<span class="sd">          A commit is done by default. Disable to avoid  committing local</span>
<span class="sd">          changes.</span>
<span class="sd">        content : bool</span>
<span class="sd">          Normally, syncing does not transfer the contents of annexed</span>
<span class="sd">          files.  This option causes the content of files in the work tree</span>
<span class="sd">          to also be uploaded and downloaded as necessary.</span>
<span class="sd">        all : bool</span>
<span class="sd">          This option, when combined with `content`, makes all available</span>
<span class="sd">          versions of all files be synced, when preferred content settings</span>
<span class="sd">          allow</span>
<span class="sd">        fast : bool</span>
<span class="sd">          Only sync with the remotes with the lowest annex-cost value</span>
<span class="sd">          configured</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;AnnexRepo.sync() is deprecated, use call_annex([&#39;sync&#39;, ...]) &quot;</span>
            <span class="s2">&quot;instead.&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">to_options</span><span class="p">(</span><span class="n">push</span><span class="o">=</span><span class="n">push</span><span class="p">,</span> <span class="n">no_push</span><span class="o">=</span><span class="ow">not</span> <span class="n">push</span><span class="p">,</span>
                               <span class="c1"># means: &#39;--push&#39; if push else &#39;--no-push&#39;</span>
                               <span class="n">pull</span><span class="o">=</span><span class="n">pull</span><span class="p">,</span> <span class="n">no_pull</span><span class="o">=</span><span class="ow">not</span> <span class="n">pull</span><span class="p">,</span>
                               <span class="n">commit</span><span class="o">=</span><span class="n">commit</span><span class="p">,</span> <span class="n">no_commit</span><span class="o">=</span><span class="ow">not</span> <span class="n">commit</span><span class="p">,</span>
                               <span class="n">content</span><span class="o">=</span><span class="n">content</span><span class="p">,</span> <span class="n">no_content</span><span class="o">=</span><span class="ow">not</span> <span class="n">content</span><span class="p">,</span>
                               <span class="nb">all</span><span class="o">=</span><span class="nb">all</span><span class="p">,</span>
                               <span class="n">fast</span><span class="o">=</span><span class="n">fast</span><span class="p">))</span>
        <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ensure_list</span><span class="p">(</span><span class="n">remotes</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">call_annex</span><span class="p">([</span><span class="s1">&#39;sync&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">args</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnexRepo.add_url_to_file"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.add_url_to_file">[docs]</a>    <span class="nd">@normalize_path</span>
    <span class="k">def</span> <span class="nf">add_url_to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">batch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">git_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">annex_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">unlink_existing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add file from url to the annex.</span>

<span class="sd">        Downloads `file` from `url` and add it to the annex.</span>
<span class="sd">        If annex knows `file` already,</span>
<span class="sd">        records that it can be downloaded from `url`.</span>

<span class="sd">        Note: Consider using the higher-level `download_url` instead.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_: str</span>

<span class="sd">        url: str</span>

<span class="sd">        options: list</span>
<span class="sd">            options to the annex command</span>

<span class="sd">        batch: bool, optional</span>
<span class="sd">            initiate or continue with a batched run of annex addurl, instead of just</span>
<span class="sd">            calling a single git annex addurl command</span>

<span class="sd">        unlink_existing: bool, optional</span>
<span class="sd">            by default crashes if file already exists and is under git.</span>
<span class="sd">            With this flag set to True would first remove it.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">          In batch mode only ATM returns dict representation of json output returned</span>
<span class="sd">          by annex</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">git_options</span><span class="p">:</span>
            <span class="n">lgr</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;add_url_to_file: git_options not yet implemented. Ignored.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">annex_options</span><span class="p">:</span>
            <span class="n">lgr</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;annex_options not yet implemented. Ignored.&quot;</span><span class="p">)</span>

        <span class="n">options</span> <span class="o">=</span> <span class="n">options</span><span class="p">[:]</span> <span class="k">if</span> <span class="n">options</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">backend</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="s1">&#39;--backend&#39;</span><span class="p">,</span> <span class="n">backend</span><span class="p">))</span>
        <span class="n">git_options</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">lexists</span><span class="p">(</span><span class="n">opj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">file_</span><span class="p">))</span> <span class="ow">and</span> \
                <span class="n">unlink_existing</span> <span class="ow">and</span> \
                <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_under_annex</span><span class="p">(</span><span class="n">file_</span><span class="p">):</span>
            <span class="c1"># already under git, we can&#39;t addurl for under annex</span>
            <span class="n">lgr</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;File </span><span class="si">%s</span><span class="s2">:</span><span class="si">%s</span><span class="s2"> is already under git, removing so it could possibly&quot;</span>
                <span class="s2">&quot; be added under annex&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">file_</span>
            <span class="p">)</span>
            <span class="n">unlink</span><span class="p">(</span><span class="n">opj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">file_</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">batch</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">fake_dates_enabled</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">batch</span><span class="p">:</span>
                <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Not batching addurl call &quot;</span>
                          <span class="s2">&quot;because fake dates are enabled&quot;</span><span class="p">)</span>
            <span class="n">files_opt</span> <span class="o">=</span> <span class="s1">&#39;--file=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">file_</span>
            <span class="n">out_json</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_annex_records</span><span class="p">(</span>
                <span class="p">[</span><span class="s1">&#39;addurl&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">options</span> <span class="o">+</span> <span class="p">[</span><span class="n">files_opt</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">url</span><span class="p">],</span>
                <span class="n">progress</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_json</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                    <span class="s2">&quot;should always be a single-item list, Got: </span><span class="si">%s</span><span class="s2">&quot;</span>
                    <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">out_json</span><span class="p">))</span>
            <span class="c1"># Make the output&#39;s structure match bcmd&#39;s.</span>
            <span class="n">out_json</span> <span class="o">=</span> <span class="n">out_json</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Don&#39;t capture stderr, since download progress provided by wget</span>
            <span class="c1"># uses stderr.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">options</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;--with-files&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">backend</span><span class="p">:</span>
                <span class="n">options</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;--backend=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">backend</span><span class="p">]</span>
            <span class="c1"># Initializes (if necessary) and obtains the batch process</span>
            <span class="n">bcmd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_batched</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="c1"># Since backend will be critical for non-existing files</span>
                <span class="s1">&#39;addurl_to_file_backend:</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">backend</span><span class="p">,</span>
                <span class="n">annex_cmd</span><span class="o">=</span><span class="s1">&#39;addurl&#39;</span><span class="p">,</span>
                <span class="n">git_options</span><span class="o">=</span><span class="n">git_options</span><span class="p">,</span>
                <span class="n">annex_options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span>  <span class="c1"># --raw ?</span>
                <span class="n">path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
                <span class="n">json</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">out_json</span> <span class="o">=</span> <span class="n">bcmd</span><span class="p">((</span><span class="n">url</span><span class="p">,</span> <span class="n">file_</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="c1"># if isinstance(exc, IOError):</span>
                <span class="c1">#     raise</span>
                <span class="k">raise</span> <span class="n">AnnexBatchCommandError</span><span class="p">(</span>
                    <span class="n">cmd</span><span class="o">=</span><span class="s2">&quot;addurl&quot;</span><span class="p">,</span>
                    <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Adding url </span><span class="si">%s</span><span class="s2"> to file </span><span class="si">%s</span><span class="s2"> failed&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">file_</span><span class="p">))</span> <span class="kn">from</span> <span class="nn">exc</span>
            <span class="k">assert</span> \
                <span class="p">(</span><span class="n">out_json</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;command&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;addurl&#39;</span><span class="p">),</span> \
                <span class="s2">&quot;no exception was raised and no &#39;command&#39; in result out_json=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">out_json</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">out_json</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;success&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">raise</span> <span class="p">(</span><span class="n">AnnexBatchCommandError</span> <span class="k">if</span> <span class="n">batch</span> <span class="k">else</span> <span class="n">CommandError</span><span class="p">)(</span>
                    <span class="n">cmd</span><span class="o">=</span><span class="s2">&quot;addurl&quot;</span><span class="p">,</span>
                    <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Error, annex reported failure for addurl (url=&#39;</span><span class="si">%s</span><span class="s2">&#39;): </span><span class="si">%s</span><span class="s2">&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">out_json</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">out_json</span></div>

<div class="viewcode-block" id="AnnexRepo.add_urls"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.add_urls">[docs]</a>    <span class="k">def</span> <span class="nf">add_urls</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">urls</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cwd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">git_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">annex_options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Downloads each url to its own file, which is added to the annex.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        urls: list of str</span>

<span class="sd">        options: list, optional</span>
<span class="sd">            options to the annex command</span>

<span class="sd">        cwd: string, optional</span>
<span class="sd">            working directory from within which to invoke git-annex</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">git_options</span><span class="p">:</span>
            <span class="n">lgr</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;add_urls: git_options not yet implemented. Ignored.&quot;</span><span class="p">)</span>

        <span class="n">git_options</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">cwd</span><span class="p">:</span>
            <span class="n">git_options</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="s1">&#39;-C&#39;</span><span class="p">,</span> <span class="n">cwd</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">annex_options</span><span class="p">:</span>
            <span class="n">lgr</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;annex_options not yet implemented. Ignored.&quot;</span><span class="p">)</span>

        <span class="n">options</span> <span class="o">=</span> <span class="n">options</span><span class="p">[:]</span> <span class="k">if</span> <span class="n">options</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">backend</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="s1">&#39;--backend&#39;</span><span class="p">,</span> <span class="n">backend</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_annex_records</span><span class="p">(</span>
            <span class="p">[</span><span class="s1">&#39;addurl&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">options</span> <span class="o">+</span> <span class="n">urls</span><span class="p">,</span>
            <span class="n">git_options</span><span class="o">=</span><span class="n">git_options</span><span class="p">,</span>
            <span class="n">progress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnexRepo.rm_url"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.rm_url">[docs]</a>    <span class="nd">@normalize_path</span>
    <span class="k">def</span> <span class="nf">rm_url</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Record that the file is no longer available at the url.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_: str</span>

<span class="sd">        url: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">call_annex</span><span class="p">([</span><span class="s1">&#39;rmurl&#39;</span><span class="p">],</span> <span class="n">files</span><span class="o">=</span><span class="p">[</span><span class="n">file_</span><span class="p">,</span> <span class="n">url</span><span class="p">])</span></div>

<div class="viewcode-block" id="AnnexRepo.get_urls"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.get_urls">[docs]</a>    <span class="nd">@normalize_path</span>
    <span class="k">def</span> <span class="nf">get_urls</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get URLs for a file/key</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_: str</span>
<span class="sd">        key: bool, optional</span>
<span class="sd">            Whether provided files are actually annex keys</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A list of URLs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">locations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">whereis</span><span class="p">(</span><span class="n">file_</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="n">batch</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">locations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">WEB_SPECIAL_REMOTE_UUID</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;urls&#39;</span><span class="p">,</span> <span class="p">[])</span></div>

<div class="viewcode-block" id="AnnexRepo.drop"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.drop">[docs]</a>    <span class="nd">@normalize_paths</span>
    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Drops the content of annexed files from this repository.</span>

<span class="sd">        Drops only if possible with respect to required minimal number of</span>
<span class="sd">        available copies.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        files: list of str</span>
<span class="sd">            paths to drop</span>
<span class="sd">        options : list of str, optional</span>
<span class="sd">            commandline options for the git annex drop command</span>
<span class="sd">        jobs : int, optional</span>
<span class="sd">            how many jobs to run in parallel (passed to git-annex call)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list(JSON objects)</span>
<span class="sd">          &#39;success&#39; item in each object indicates failure/success per file</span>
<span class="sd">          path.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># annex drop takes either files or options</span>
        <span class="c1"># --all, --unused, --key, or --incomplete</span>
        <span class="c1"># for now, most simple test; to be replaced by a more general solution</span>
        <span class="c1"># (exception thrown by _run_annex_command)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">files</span> <span class="ow">and</span> \
                <span class="p">(</span><span class="ow">not</span> <span class="n">options</span> <span class="ow">or</span>
                 <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">o</span> <span class="ow">in</span> <span class="n">options</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span>
                          <span class="p">[</span><span class="s2">&quot;--all&quot;</span><span class="p">,</span> <span class="s2">&quot;--unused&quot;</span><span class="p">,</span> <span class="s2">&quot;--key&quot;</span><span class="p">,</span> <span class="s2">&quot;--incomplete&quot;</span><span class="p">]])):</span>
            <span class="k">raise</span> <span class="n">InsufficientArgumentsError</span><span class="p">(</span><span class="s2">&quot;drop() requires at least to &quot;</span>
                                             <span class="s2">&quot;specify &#39;files&#39; or &#39;options&#39;&quot;</span><span class="p">)</span>

        <span class="n">options</span> <span class="o">=</span> <span class="n">ensure_list</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
            <span class="c1"># we can&#39;t drop multiple in 1 line, and there is no --batch yet, so</span>
            <span class="c1"># one at a time</span>
            <span class="n">files</span> <span class="o">=</span> <span class="n">ensure_list</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
            <span class="n">options</span> <span class="o">=</span> <span class="n">options</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;--key&#39;</span><span class="p">]</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_call_annex_records</span><span class="p">(</span>
                    <span class="p">[</span><span class="s1">&#39;drop&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">options</span> <span class="o">+</span> <span class="p">[</span><span class="n">k</span><span class="p">],</span>
                    <span class="n">jobs</span><span class="o">=</span><span class="n">jobs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">files</span>
            <span class="p">]</span>
            <span class="c1"># `normalize_paths` ... magic, useful?</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_annex_records</span><span class="p">(</span>
                <span class="p">[</span><span class="s1">&#39;drop&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">options</span><span class="p">,</span>
                <span class="n">files</span><span class="o">=</span><span class="n">files</span><span class="p">,</span>
                <span class="n">jobs</span><span class="o">=</span><span class="n">jobs</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnexRepo.drop_key"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.drop_key">[docs]</a>    <span class="k">def</span> <span class="nf">drop_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Drops the content of annexed files from this repository referenced by keys</span>

<span class="sd">        Dangerous: it drops without checking for required minimal number of</span>
<span class="sd">        available copies.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keys: list of str, str</span>

<span class="sd">        batch: bool, optional</span>
<span class="sd">            initiate or continue with a batched run of annex dropkey, instead of just</span>
<span class="sd">            calling a single git annex dropkey command</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">keys</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">keys</span>

        <span class="n">options</span> <span class="o">=</span> <span class="n">options</span><span class="p">[:]</span> <span class="k">if</span> <span class="n">options</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="n">options</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;--force&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">batch</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">fake_dates_enabled</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">batch</span><span class="p">:</span>
                <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Not batching drop_key call &quot;</span>
                          <span class="s2">&quot;because fake dates are enabled&quot;</span><span class="p">)</span>
            <span class="n">json_objects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_annex_records</span><span class="p">(</span>
                <span class="p">[</span><span class="s1">&#39;dropkey&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">options</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="n">keys</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">json_objects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_batched</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s1">&#39;dropkey&#39;</span><span class="p">,</span>
                <span class="n">annex_options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span> <span class="n">json</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span>
            <span class="p">)(</span><span class="n">keys</span><span class="p">)</span>
        <span class="c1"># TODO: RF to be consistent with the rest (IncompleteResultError or alike)</span>
        <span class="c1"># and/or completely refactor since drop above also has key option</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">json_objects</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;success&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>

    <span class="c1"># TODO: a dedicated unit-test</span>
    <span class="k">def</span> <span class="nf">_whereis_json_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert json record returned by annex whereis --json to our dict representation for it</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># process &#39;whereis&#39; containing list of remotes</span>
        <span class="n">remotes</span> <span class="o">=</span> <span class="p">{</span><span class="n">remote</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">]:</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">remote</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;description&#39;</span><span class="p">,</span> <span class="s1">&#39;here&#39;</span><span class="p">,</span> <span class="s1">&#39;urls&#39;</span><span class="p">)</span>
                                    <span class="p">}</span>
                   <span class="k">for</span> <span class="n">remote</span> <span class="ow">in</span> <span class="n">j</span><span class="p">[</span><span class="s1">&#39;whereis&#39;</span><span class="p">]}</span>
        <span class="k">return</span> <span class="n">remotes</span>

    <span class="c1"># TODO: reconsider having any magic at all and maybe just return a list/dict always</span>
<div class="viewcode-block" id="AnnexRepo.whereis"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.whereis">[docs]</a>    <span class="nd">@normalize_paths</span>
    <span class="k">def</span> <span class="nf">whereis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;uuids&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lists repositories that have actual content of file(s).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        files: list of str</span>
<span class="sd">            files to look for</span>
<span class="sd">        output: {&#39;descriptions&#39;, &#39;uuids&#39;, &#39;full&#39;}, optional</span>
<span class="sd">            If &#39;descriptions&#39;, a list of remotes descriptions returned is per</span>
<span class="sd">            each file. If &#39;full&#39;, for each file a dictionary of all fields</span>
<span class="sd">            is returned as returned by annex</span>
<span class="sd">        key: bool, optional</span>
<span class="sd">            Whether provided files are actually annex keys</span>
<span class="sd">        options: list, optional</span>
<span class="sd">            Options to pass into git-annex call</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of list of unicode  or dict</span>
<span class="sd">            if output == &#39;descriptions&#39;, contains a list of descriptions of remotes</span>
<span class="sd">            for each input file, describing the remote for each remote, which</span>
<span class="sd">            was found by git-annex whereis, like::</span>

<span class="sd">                u&#39;me@mycomputer:~/where/my/repo/is [origin]&#39; or</span>
<span class="sd">                u&#39;web&#39; or</span>
<span class="sd">                u&#39;me@mycomputer:~/some/other/clone&#39;</span>

<span class="sd">            if output == &#39;uuids&#39;, returns a list of uuids.</span>
<span class="sd">            if output == &#39;full&#39;, returns a dictionary with filenames as keys</span>
<span class="sd">            and values a detailed record, e.g.::</span>

<span class="sd">                {&#39;00000000-0000-0000-0000-000000000001&#39;: {</span>
<span class="sd">                  &#39;description&#39;: &#39;web&#39;,</span>
<span class="sd">                  &#39;here&#39;: False,</span>
<span class="sd">                  &#39;urls&#39;: [&#39;http://127.0.0.1:43442/about.txt&#39;, &#39;http://example.com/someurl&#39;]</span>
<span class="sd">                }}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">OUTPUTS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;descriptions&#39;</span><span class="p">,</span> <span class="s1">&#39;uuids&#39;</span><span class="p">,</span> <span class="s1">&#39;full&#39;</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">output</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">OUTPUTS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Unknown value output=</span><span class="si">%r</span><span class="s2">. Known are </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">repr</span><span class="p">,</span> <span class="n">OUTPUTS</span><span class="p">)))</span>
            <span class="p">)</span>

        <span class="n">options</span> <span class="o">=</span> <span class="n">ensure_list</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">batch</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;batch=True is incompatible with `key`&quot;</span><span class="p">)</span>
            <span class="n">bcmd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_batched</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;whereis&#39;</span><span class="p">,</span> <span class="n">annex_options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span>
                                     <span class="n">json</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="n">json_objects</span> <span class="o">=</span> <span class="n">bcmd</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;whereis&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">options</span>
            <span class="n">files_arg</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
                <span class="n">cmd</span> <span class="o">=</span> <span class="n">cmd</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;--key&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">files</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">files_arg</span> <span class="o">=</span> <span class="n">files</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">json_objects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_annex_records</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="n">files_arg</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">CommandError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Invalid&#39;</span><span class="p">):</span>
                    <span class="c1"># would happen when git-annex is called with incompatible options</span>
                    <span class="k">raise</span>
                <span class="c1"># whereis may exit non-zero when there are too few known copies</span>
                <span class="c1"># callers of whereis are interested in exactly that information,</span>
                <span class="c1"># which we deliver via result, not via exception</span>
                <span class="n">json_objects</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;stdout_json&#39;</span><span class="p">,</span> <span class="p">[])</span>

        <span class="k">if</span> <span class="n">output</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;descriptions&#39;</span><span class="p">,</span> <span class="s1">&#39;uuids&#39;</span><span class="p">}:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="p">[</span><span class="n">remote</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">output</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">remote</span> <span class="ow">in</span> <span class="n">j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;whereis&#39;</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;success&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">json_objects</span>
            <span class="p">]</span>
        <span class="k">elif</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;full&#39;</span><span class="p">:</span>
            <span class="c1"># TODO: we might want to optimize storage since many remotes entries will be the</span>
            <span class="c1"># same so we could just reuse them instead of brewing copies</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="n">j</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="ow">or</span> <span class="s1">&#39;--all&#39;</span> <span class="ow">in</span> <span class="n">options</span><span class="p">)</span>
                <span class="c1"># report is always POSIX, but normalize_paths wants to match against</span>
                <span class="c1"># the native representation</span>
                <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="n">PurePosixPath</span><span class="p">(</span><span class="n">j</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">])))</span>
                <span class="k">if</span> <span class="n">on_windows</span> <span class="k">else</span> <span class="n">j</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span>
                <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_whereis_json_to_dict</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">json_objects</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.this-is-a-test-key&#39;</span><span class="p">)</span>
            <span class="p">}</span></div>

    <span class="c1"># TODO:</span>
    <span class="c1"># I think we should make interface cleaner and less ambiguous for those annex</span>
    <span class="c1"># commands which could operate on globs, files, and entire repositories, separating</span>
    <span class="c1"># those out, e.g. annex_info_repo, annex_info_files at least.</span>
    <span class="c1"># If we make our calling wrappers work without relying on invoking from repo topdir,</span>
    <span class="c1"># then returned filenames would not need to be mapped, so we could easily work on dirs</span>
    <span class="c1"># and globs.</span>
    <span class="c1"># OR if explicit filenames list - return list of matching entries, if globs/dirs -- return dict?</span>
<div class="viewcode-block" id="AnnexRepo.info"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.info">[docs]</a>    <span class="nd">@normalize_paths</span><span class="p">(</span><span class="n">map_filenames_back</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Provide annex info for file(s).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        files: list of str</span>
<span class="sd">            files to look for</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">          Info for each file</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;--bytes&#39;</span><span class="p">,</span> <span class="s1">&#39;--fast&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">fast</span> <span class="k">else</span> <span class="p">[</span><span class="s1">&#39;--bytes&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">batch</span><span class="p">:</span>
            <span class="n">json_objects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_annex_records</span><span class="p">(</span>
                <span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">options</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="n">files</span><span class="p">,</span> <span class="n">merge_annex_branches</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">json_objects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_batched</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s1">&#39;info&#39;</span><span class="p">,</span>
                <span class="n">annex_options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span> <span class="n">json</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
                <span class="n">git_options</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;-c&#39;</span><span class="p">,</span> <span class="s1">&#39;annex.merge-annex-branches=false&#39;</span><span class="p">]</span>
            <span class="p">)(</span><span class="n">files</span><span class="p">)</span>

        <span class="c1"># Some aggressive checks. ATM info can be requested only per file</span>
        <span class="c1"># json_objects is a generator, let&#39;s keep it that way</span>
        <span class="c1"># assert(len(json_objects) == len(files))</span>
        <span class="c1"># and that they all have &#39;file&#39; equal to the passed one</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">json_objects</span><span class="p">,</span> <span class="n">files</span><span class="p">):</span>
            <span class="c1"># Starting with version of annex 8.20200330-100-g957a87b43</span>
            <span class="c1"># annex started to normalize relative paths.</span>
            <span class="c1"># ref: https://github.com/datalad/datalad/issues/4431</span>
            <span class="c1"># Use normpath around each side to ensure it is the same file</span>
            <span class="k">assert</span> <span class="n">normpath</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;file&#39;</span><span class="p">))</span> <span class="o">==</span> <span class="n">normpath</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">j</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">]:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;success&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span>
                <span class="c1"># convert size to int</span>
                <span class="n">j</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">])</span> <span class="k">if</span> <span class="s1">&#39;unknown&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">j</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="c1"># and pop the &quot;command&quot; field</span>
                <span class="n">j</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;command&quot;</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="AnnexRepo.repo_info"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.repo_info">[docs]</a>    <span class="k">def</span> <span class="nf">repo_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">merge_annex_branches</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Provide annex info for the entire repository.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fast : bool, optional</span>
<span class="sd">          Pass `--fast` to `git annex info`.</span>
<span class="sd">        merge_annex_branches : bool, optional</span>
<span class="sd">          Whether to allow git-annex if needed to merge annex branches, e.g. to</span>
<span class="sd">          make sure up to date descriptions for git annex remotes</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">          Info for the repository, with keys matching the ones returned by annex</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;--bytes&#39;</span><span class="p">,</span> <span class="s1">&#39;--fast&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">fast</span> <span class="k">else</span> <span class="p">[</span><span class="s1">&#39;--bytes&#39;</span><span class="p">]</span>

        <span class="n">json_records</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_call_annex_records</span><span class="p">(</span>
            <span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">options</span><span class="p">,</span> <span class="n">merge_annex_branches</span><span class="o">=</span><span class="n">merge_annex_branches</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">json_records</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># TODO: we need to abstract/centralize conversion from annex fields</span>
        <span class="c1"># For now just tune up few for immediate usability</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">json_records</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">info</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39; size&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">k</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39; disk space&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;size of &#39;</span><span class="p">):</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">size</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                    <span class="n">info</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Size </span><span class="si">%r</span><span class="s2"> reported to be </span><span class="si">%s</span><span class="s2">, setting to None&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
                    <span class="n">info</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;success&#39;</span><span class="p">))</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;command&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;info&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">info</span>  <span class="c1"># just as is for now</span></div>

<div class="viewcode-block" id="AnnexRepo.get_annexed_files"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.get_annexed_files">[docs]</a>    <span class="k">def</span> <span class="nf">get_annexed_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_content_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">patterns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a list of files in annex</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        with_content_only : bool, optional</span>
<span class="sd">            Only list files whose content is present.</span>
<span class="sd">        patterns : list, optional</span>
<span class="sd">            Globs to pass to annex&#39;s `--include=`. Files that match any of</span>
<span class="sd">            these will be returned (i.e., they&#39;ll be separated by `--or`).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A list of POSIX file names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">patterns</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">with_content_only</span> <span class="k">else</span> <span class="p">[</span><span class="s1">&#39;--include&#39;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">patterns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;--include&#39;</span><span class="p">,</span> <span class="n">patterns</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;-(&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">pat</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;--include&#39;</span><span class="p">,</span> <span class="n">pat</span><span class="p">,</span> <span class="s2">&quot;--or&quot;</span><span class="p">])</span>
                <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;--include&#39;</span><span class="p">,</span> <span class="n">patterns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;-)&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">with_content_only</span><span class="p">:</span>
                <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;--in&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">])</span>
        <span class="c1"># TODO: JSON</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">call_annex_items_</span><span class="p">(</span>
                <span class="p">[</span><span class="s1">&#39;find&#39;</span><span class="p">,</span> <span class="s1">&#39;-c&#39;</span><span class="p">,</span> <span class="s1">&#39;annex.merge-annex-branches=false&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">args</span><span class="p">))</span></div>

<div class="viewcode-block" id="AnnexRepo.get_preferred_content"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.get_preferred_content">[docs]</a>    <span class="k">def</span> <span class="nf">get_preferred_content</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">property</span><span class="p">,</span> <span class="n">remote</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get preferred content configuration of a repository or remote</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        property : {&#39;wanted&#39;, &#39;required&#39;, &#39;group&#39;}</span>
<span class="sd">          Type of property to query</span>
<span class="sd">        remote : str, optional</span>
<span class="sd">          If not specified (None), returns the property for the local</span>
<span class="sd">          repository.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">          Whether the setting is returned, or `None` if there is none.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">          If an unknown property label is given.</span>

<span class="sd">        CommandError</span>
<span class="sd">          If the annex call errors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">property</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;wanted&#39;</span><span class="p">,</span> <span class="s1">&#39;required&#39;</span><span class="p">,</span> <span class="s1">&#39;group&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;unknown preferred content property: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">property</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_annex_oneline</span><span class="p">([</span><span class="nb">property</span><span class="p">,</span> <span class="n">remote</span> <span class="ow">or</span> <span class="s1">&#39;.&#39;</span><span class="p">])</span> <span class="ow">or</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="AnnexRepo.set_preferred_content"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.set_preferred_content">[docs]</a>    <span class="k">def</span> <span class="nf">set_preferred_content</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">property</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">remote</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set preferred content configuration of a repository or remote</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        property : {&#39;wanted&#39;, &#39;required&#39;, &#39;group&#39;}</span>
<span class="sd">          Type of property to query</span>
<span class="sd">        expr : str</span>
<span class="sd">          Any expression or label supported by git-annex for the</span>
<span class="sd">          given property.</span>
<span class="sd">        remote : str, optional</span>
<span class="sd">          If not specified (None), sets the property for the local</span>
<span class="sd">          repository.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">          Raw git-annex output in response to the set command.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">          If an unknown property label is given.</span>

<span class="sd">        CommandError</span>
<span class="sd">          If the annex call errors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">property</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;wanted&#39;</span><span class="p">,</span> <span class="s1">&#39;required&#39;</span><span class="p">,</span> <span class="s1">&#39;group&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;unknown preferred content property: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">property</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_annex_oneline</span><span class="p">([</span><span class="nb">property</span><span class="p">,</span> <span class="n">remote</span> <span class="ow">or</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">expr</span><span class="p">])</span></div>

<div class="viewcode-block" id="AnnexRepo.get_groupwanted"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.get_groupwanted">[docs]</a>    <span class="k">def</span> <span class="nf">get_groupwanted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get `groupwanted` expression for a group `name`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">           Name of the groupwanted group</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_annex_oneline</span><span class="p">([</span><span class="s1">&#39;groupwanted&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">])</span></div>

<div class="viewcode-block" id="AnnexRepo.set_groupwanted"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.set_groupwanted">[docs]</a>    <span class="k">def</span> <span class="nf">set_groupwanted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set `expr` for the `name` groupwanted&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_annex_oneline</span><span class="p">([</span><span class="s1">&#39;groupwanted&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">expr</span><span class="p">])</span></div>

<div class="viewcode-block" id="AnnexRepo.precommit"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.precommit">[docs]</a>    <span class="k">def</span> <span class="nf">precommit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform pre-commit maintenance tasks, such as closing all batched annexes</span>
<span class="sd">        since they might still need to flush their changes into index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_batched</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_batched</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AnnexRepo</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">precommit</span><span class="p">()</span></div>


<div class="viewcode-block" id="AnnexRepo.remove"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.remove">[docs]</a>    <span class="nd">@normalize_paths</span><span class="p">(</span><span class="n">match_return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove files from git/annex</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        files</span>
<span class="sd">        force: bool, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: parameter &#39;force&#39; unnecessary =&gt; kwargs / to_options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precommit</span><span class="p">()</span>  <span class="c1"># since might interfere</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">AnnexRepo</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">,</span>
                                             <span class="n">normalize_paths</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnexRepo.get_contentlocation"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.get_contentlocation">[docs]</a>    <span class="k">def</span> <span class="nf">get_contentlocation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get location of the key content</span>

<span class="sd">        Normally under .git/annex objects in indirect mode and within file</span>
<span class="sd">        tree in direct mode.</span>

<span class="sd">        Unfortunately there is no (easy) way to discriminate situations</span>
<span class="sd">        when given key is simply incorrect (not known to annex) or its content</span>
<span class="sd">        not currently present -- in both cases annex just silently exits with -1</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key: str</span>
<span class="sd">            key</span>
<span class="sd">        batch: bool, optional</span>
<span class="sd">            initiate or continue with a batched run of annex contentlocation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            path relative to the top directory of the repository. If no content</span>
<span class="sd">            is present, empty string is returned</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">batch</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">call_annex_items_</span><span class="p">([</span><span class="s1">&#39;contentlocation&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">]))</span>
            <span class="k">except</span> <span class="n">CommandError</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_batched</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;contentlocation&#39;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)(</span><span class="n">key</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnexRepo.is_available"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.is_available">[docs]</a>    <span class="nd">@normalize_paths</span><span class="p">(</span><span class="n">serialize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">is_available</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_</span><span class="p">,</span> <span class="n">remote</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if file or key is available (from a remote)</span>

<span class="sd">        In case if key or remote is misspecified, it wouldn&#39;t fail but just keep</span>
<span class="sd">        returning False, although possibly also complaining out loud ;)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_: str</span>
<span class="sd">            Filename or a key</span>
<span class="sd">        remote: str, optional</span>
<span class="sd">            Remote which to check.  If None, possibly multiple remotes are checked</span>
<span class="sd">            before positive result is reported</span>
<span class="sd">        key: bool, optional</span>
<span class="sd">            Whether provided files are actually annex keys</span>
<span class="sd">        batch: bool, optional</span>
<span class="sd">            Initiate or continue with a batched run of annex checkpresentkey</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            with True indicating that file/key is available from (the) remote</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
            <span class="n">key_</span> <span class="o">=</span> <span class="n">file_</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO with eval_availability=True, the following call</span>
            <span class="c1"># would already provide the answer to is_available? for</span>
            <span class="c1"># the local annex</span>
            <span class="n">key_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_file_annexinfo</span><span class="p">(</span><span class="n">file_</span><span class="p">)[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span>  <span class="c1"># ?, batch=batch</span>

        <span class="n">annex_input</span> <span class="o">=</span> <span class="p">[</span><span class="n">key_</span><span class="p">,]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">remote</span> <span class="k">else</span> <span class="p">[</span><span class="n">key_</span><span class="p">,</span> <span class="n">remote</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">batch</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_annex</span><span class="p">([</span><span class="s1">&#39;checkpresentkey&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">annex_input</span><span class="p">)</span>
                <span class="k">assert</span><span class="p">(</span><span class="ow">not</span> <span class="n">out</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">except</span> <span class="n">CommandError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">annex_cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;checkpresentkey&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">([</span><span class="n">remote</span><span class="p">]</span> <span class="k">if</span> <span class="n">remote</span> <span class="k">else</span> <span class="p">[])</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_batched</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s1">&#39;:&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">annex_cmd</span><span class="p">),</span> <span class="n">annex_cmd</span><span class="p">,</span>
                <span class="n">path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)(</span><span class="n">key_</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="c1"># happens on travis in direct/heavy-debug mode, that process</span>
                    <span class="c1"># exits and closes stdout (upon unknown key) before we could</span>
                    <span class="c1"># read it, so we get None as the stdout.</span>
                    <span class="c1"># see https://github.com/datalad/datalad/issues/2330</span>
                    <span class="c1"># but it is associated with an unknown key, and for consistency</span>
                    <span class="c1"># we report False there too, as to &#39;&#39;</span>
                    <span class="kc">None</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>  <span class="c1"># when remote is misspecified ... stderr carries the msg</span>
                    <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">}[</span><span class="n">out</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Received output </span><span class="si">%r</span><span class="s2"> from annex, whenever expect 0 or 1&quot;</span> <span class="o">%</span> <span class="n">out</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="AnnexRepo.migrate_backend"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.migrate_backend">[docs]</a>    <span class="nd">@normalize_paths</span>
    <span class="k">def</span> <span class="nf">migrate_backend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Changes the backend used for `file`.</span>

<span class="sd">        The backend used for the key-value of `files`. Only files currently</span>
<span class="sd">        present are migrated.</span>
<span class="sd">        Note: There will be no notification if migrating fails due to the</span>
<span class="sd">        absence of a file&#39;s content!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        files: list</span>
<span class="sd">            files to migrate.</span>
<span class="sd">        backend: str</span>
<span class="sd">            specify the backend to migrate to. If none is given, the</span>
<span class="sd">            default backend of this instance will be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_direct_mode</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">CommandNotAvailableError</span><span class="p">(</span>
                <span class="s1">&#39;git-annex migrate&#39;</span><span class="p">,</span>
                <span class="s2">&quot;Command &#39;migrate&#39; is not available in direct mode.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call_annex</span><span class="p">(</span>
            <span class="p">[</span><span class="s1">&#39;migrate&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">([</span><span class="s1">&#39;--backend&#39;</span><span class="p">,</span> <span class="n">backend</span><span class="p">]</span> <span class="k">if</span> <span class="n">backend</span> <span class="k">else</span> <span class="p">[]),</span>
            <span class="n">files</span><span class="o">=</span><span class="n">files</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="AnnexRepo.get_key_backend"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.get_key_backend">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_key_backend</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the backend from a given key&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="AnnexRepo.get_file_backend"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.get_file_backend">[docs]</a>    <span class="nd">@normalize_paths</span>
    <span class="k">def</span> <span class="nf">get_file_backend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the backend currently used for file(s).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        files: list of str</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of str</span>
<span class="sd">            For each file in input list indicates the used backend by a str</span>
<span class="sd">            like &quot;SHA256E&quot; or &quot;MD5&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">[</span>
            <span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;backend&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_content_annexinfo</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">default_backends</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">reload</span><span class="p">()</span>
        <span class="c1"># TODO: Deprecate and remove this property? It&#39;s used in the tests and</span>
        <span class="c1"># datalad-crawler.</span>
        <span class="c1">#</span>
        <span class="c1"># git-annex used to try the list of backends in annex.backends in</span>
        <span class="c1"># order. Now it takes annex.backend if set, falling back to the first</span>
        <span class="c1"># value of annex.backends. See 4c1e3210f (annex.backend is the new name</span>
        <span class="c1"># for what was annex.backends, 2017-05-09).</span>
        <span class="n">backend</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gitattributes</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="s1">&#39;.&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s1">&#39;annex.backend&#39;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;annex.backend&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">backend</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">backend</span><span class="p">]</span>

        <span class="n">backends</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;annex.backends&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">backends</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">backends</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># comment out presently unnecessary functionality, bring back once needed</span>
    <span class="c1">#def fsck(self, paths=None, remote=None, fast=False, incremental=False,</span>
    <span class="c1">#         limit=None, annex_options=None, git_options=None):</span>
<div class="viewcode-block" id="AnnexRepo.fsck"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.fsck">[docs]</a>    <span class="k">def</span> <span class="nf">fsck</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remote</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">annex_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">git_options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Front-end for git-annex fsck</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        paths : list</span>
<span class="sd">          Limit operation to specific paths.</span>
<span class="sd">        remote : str</span>
<span class="sd">          If given, the identified remote will be fsck&#39;ed instead of the</span>
<span class="sd">          local repository.</span>
<span class="sd">        fast : bool</span>
<span class="sd">          If True, typically means that no actual content is being verified,</span>
<span class="sd">          but tests are limited to the presence of files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#incremental : bool or {&#39;continue&#39;} or SCHEDULE</span>
        <span class="c1">#  If given, `fsck` is called with `--incremental`. If &#39;continue&#39;,</span>
        <span class="c1">#  `fsck` is additionally called with `--more`, and any other argument</span>
        <span class="c1">#  is given to `--incremental-schedule`.</span>
        <span class="c1">#limit : str or all</span>
        <span class="c1">#  If the function `all` is given, `fsck` is called with `--all`. Any</span>
        <span class="c1">#  other value is passed on to `--branch`.</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">annex_options</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">annex_options</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fast</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;--fast&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">remote</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;--from=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">remote</span><span class="p">))</span>
        <span class="c1">#if limit:</span>
        <span class="c1">#    # looks funky, but really is a test if the `all` function was passed</span>
        <span class="c1">#    # alternatives would have been 1) a dedicated argument (would need</span>
        <span class="c1">#    # a check for mutual exclusivity with --branch), or 2) a str-type</span>
        <span class="c1">#    # special values that has no meaning in Git and is less confusing</span>
        <span class="c1">#    if limit is all:</span>
        <span class="c1">#        args.append(&#39;--all&#39;)</span>
        <span class="c1">#    else:</span>
        <span class="c1">#        args.append(&#39;--branch={}&#39;.format(limit))</span>
        <span class="c1">#if incremental == &#39;continue&#39;:</span>
        <span class="c1">#    args.append(&#39;--more&#39;)</span>
        <span class="c1">#elif incremental:</span>
        <span class="c1">#    args.append(&#39;--incremental&#39;)</span>
        <span class="c1">#    if not (incremental is True):</span>
        <span class="c1">#        args.append(&#39;--incremental-schedule={}&#39;.format(incremental))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_annex_records</span><span class="p">(</span>
                <span class="p">[</span><span class="s1">&#39;fsck&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">args</span><span class="p">,</span>
                <span class="n">files</span><span class="o">=</span><span class="n">paths</span><span class="p">,</span>
                <span class="n">git_options</span><span class="o">=</span><span class="n">git_options</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="n">CommandError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># fsck may exit non-zero when there are too few known copies</span>
            <span class="c1"># callers of whereis are interested in exactly that information,</span>
            <span class="c1"># which we deliver via result, not via exception</span>
            <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;stdout_json&#39;</span><span class="p">,</span> <span class="p">[])</span></div>

    <span class="c1"># We need --auto and --fast having exposed  TODO</span>
<div class="viewcode-block" id="AnnexRepo.copy_to"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.copy_to">[docs]</a>    <span class="nd">@normalize_paths</span><span class="p">(</span><span class="n">match_return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># get a list even in case of a single item</span>
    <span class="k">def</span> <span class="nf">copy_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">remote</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy the actual content of `files` to `remote`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        files: str or list of str</span>
<span class="sd">            path(s) to copy</span>
<span class="sd">        remote: str</span>
<span class="sd">            name of remote to copy `files` to</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of str</span>
<span class="sd">           files successfully copied</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;AnnexRepo.copy_to() is deprecated and will be removed in a &quot;</span>
            <span class="s2">&quot;future release. Use the Dataset method push() instead.&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">)</span>

        <span class="c1"># find --in here --not --in remote</span>
        <span class="c1"># TODO: full support of annex copy options would lead to `files` being</span>
        <span class="c1"># optional. This means to check for whether files or certain options are</span>
        <span class="c1"># given and fail or just pass everything as is and try to figure out,</span>
        <span class="c1"># what was going on when catching CommandError</span>

        <span class="k">if</span> <span class="n">remote</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_remotes</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown remote &#39;</span><span class="si">{0}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">remote</span><span class="p">))</span>

        <span class="n">options</span> <span class="o">=</span> <span class="n">options</span><span class="p">[:]</span> <span class="k">if</span> <span class="n">options</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="c1"># Note:</span>
        <span class="c1"># In case of single path, &#39;annex copy&#39; will fail, if it cannot copy it.</span>
        <span class="c1"># With multiple files, annex will just skip the ones, it cannot deal</span>
        <span class="c1"># with. We&#39;ll do the same and report back what was successful</span>
        <span class="c1"># (see return value).</span>
        <span class="c1"># Therefore raise telling exceptions before even calling annex:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Note, that for isdir we actually need an absolute path (which we don&#39;t get via normalize_paths)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isdir</span><span class="p">(</span><span class="n">opj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="c1"># for non-existing paths, get_file_annexinfo() will raise already</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_file_annexinfo</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">FileInGitError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No known annex key for a file </span><span class="si">{</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">. Cannot copy&#39;</span><span class="p">)</span>

        <span class="c1"># TODO: RF -- logic is duplicated with get() -- the only difference</span>
        <span class="c1"># is the verb (copy, copy) or (get, put) and remote (&#39;here&#39;, remote)?</span>
        <span class="k">if</span> <span class="s1">&#39;--key&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
            <span class="n">expected_copys</span><span class="p">,</span> <span class="n">copy_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_expected_files</span><span class="p">(</span>
                <span class="n">files</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;--in&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;--not&#39;</span><span class="p">,</span> <span class="s1">&#39;--in&#39;</span><span class="p">,</span> <span class="n">remote</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">copy_files</span> <span class="o">=</span> <span class="n">files</span>
            <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">expected_copys</span> <span class="o">=</span> <span class="p">{</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">AnnexRepo</span><span class="o">.</span><span class="n">get_size_from_key</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">])}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">copy_files</span><span class="p">:</span>
            <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;No files found needing copying.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">copy_files</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">):</span>
            <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Actually copying </span><span class="si">%d</span><span class="s2"> files&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">copy_files</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_open_ssh_connection</span><span class="p">(</span><span class="n">remote</span><span class="p">)</span>
        <span class="n">annex_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;--to=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">remote</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">options</span><span class="p">:</span>
            <span class="n">annex_options</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">split_cmdline</span><span class="p">(</span><span class="n">options</span><span class="p">))</span>

        <span class="c1"># filter out keys with missing size info</span>
        <span class="n">total_nbytes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expected_copys</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span><span class="p">)</span> <span class="ow">or</span> <span class="kc">None</span>

        <span class="c1"># TODO: provide more meaningful message (possibly aggregating &#39;note&#39;</span>
        <span class="c1">#  from annex failed ones</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_annex_records</span><span class="p">(</span>
            <span class="p">[</span><span class="s1">&#39;copy&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">annex_options</span><span class="p">,</span>
            <span class="n">files</span><span class="o">=</span><span class="n">files</span><span class="p">,</span>  <span class="c1"># copy_files,</span>
            <span class="n">jobs</span><span class="o">=</span><span class="n">jobs</span><span class="p">,</span>
            <span class="n">progress</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">total_nbytes</span><span class="o">=</span><span class="n">total_nbytes</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">results_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="c1"># XXX this is the only logic different ATM from get</span>
        <span class="c1"># check if any transfer failed since then we should just raise an Exception</span>
        <span class="c1"># for now to guarantee consistent behavior with non--json output</span>
        <span class="c1"># see https://github.com/datalad/datalad/pull/1349#discussion_r103639456</span>
        <span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
        <span class="n">failed_copies</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">results_list</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">]]</span>
        <span class="n">good_copies</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">e</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">results_list</span>
            <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">]</span> <span class="ow">and</span>
               <span class="n">e</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;note&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;to &#39;</span><span class="p">)</span>  <span class="c1"># transfer did happen</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">failed_copies</span><span class="p">:</span>
            <span class="c1"># TODO: RF for new fancy scheme of outputs reporting</span>
            <span class="k">raise</span> <span class="n">IncompleteResultsError</span><span class="p">(</span>
                <span class="n">results</span><span class="o">=</span><span class="n">good_copies</span><span class="p">,</span> <span class="n">failed</span><span class="o">=</span><span class="n">failed_copies</span><span class="p">,</span>
                <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Failed to copy </span><span class="si">%d</span><span class="s2"> file(s)&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">failed_copies</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">good_copies</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">uuid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Annex UUID</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">          Returns a the annex UUID, if there is any, or `None` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uuid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_uuid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;annex.uuid&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uuid</span>

<div class="viewcode-block" id="AnnexRepo.get_description"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.get_description">[docs]</a>    <span class="k">def</span> <span class="nf">get_description</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uuid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get annex repository description</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uuid : str, optional</span>
<span class="sd">          For which remote (based on uuid) to report description for</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str or None</span>
<span class="sd">          None returned if not found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">repo_info</span><span class="p">(</span><span class="n">fast</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">match</span> <span class="o">=</span> \
            <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;here&#39;</span><span class="p">])</span> \
            <span class="k">if</span> <span class="n">uuid</span> <span class="ow">is</span> <span class="kc">None</span> \
            <span class="k">else</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">uuid</span><span class="p">)</span>

        <span class="n">matches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">remotes</span> <span class="k">if</span> <span class="n">match</span><span class="p">(</span><span class="n">r</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">remotes</span> <span class="ow">in</span> <span class="n">info</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39; repositories&#39;</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># single hit as it should</span>
            <span class="k">return</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">lgr</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Found multiple hits while searching. Returning first among: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="AnnexRepo.get_metadata"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.get_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">get_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">timestamps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Query git-annex file metadata</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        files : str or iterable(str)</span>
<span class="sd">          One or more paths for which metadata is to be queried. If one</span>
<span class="sd">          or more paths could be directories, `batch=False` must be given</span>
<span class="sd">          to prevent git-annex given an error. Due to technical limitations,</span>
<span class="sd">          such error will lead to a hanging process.</span>
<span class="sd">        timestamps: bool, optional</span>
<span class="sd">          If True, the output contains a &#39;&lt;metadatakey&gt;-lastchanged&#39;</span>
<span class="sd">          key for every metadata item, reflecting the modification</span>
<span class="sd">          time, as well as a &#39;lastchanged&#39; key with the most recent</span>
<span class="sd">          modification time of any metadata item.</span>
<span class="sd">        batch: bool, optional</span>
<span class="sd">          If True, a `metadata --batch` process will be used, and only</span>
<span class="sd">          confirmed annex&#39;ed files can be queried (else query will hang</span>
<span class="sd">          indefinitely). If False, invokes without --batch, and gives all files</span>
<span class="sd">          as arguments (this can be problematic with a large number of files).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        generator</span>
<span class="sd">          One tuple per file (could be more items than input arguments</span>
<span class="sd">          when directories are given). First tuple item is the filename,</span>
<span class="sd">          second item is a dictionary with metadata key/value pairs. Note that annex</span>
<span class="sd">          metadata tags are stored under the key &#39;tag&#39;, which is a</span>
<span class="sd">          regular metadata item that can be manipulated like any other.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_format_response</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="n">PurePosixPath</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]))),</span>
                <span class="n">res</span><span class="p">[</span><span class="s1">&#39;fields&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">timestamps</span> <span class="k">else</span> \
                <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;fields&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                 <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;lastchanged&#39;</span><span class="p">)}</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">files</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">batch</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1"># we can be lazy</span>
            <span class="n">files</span> <span class="o">=</span> <span class="n">ensure_list</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">files</span><span class="p">]</span>
            <span class="c1"># anything else is assumed to be an iterable (e.g. a generator)</span>
        <span class="k">if</span> <span class="n">batch</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_annex_records</span><span class="p">([</span><span class="s1">&#39;metadata&#39;</span><span class="p">],</span> <span class="n">files</span><span class="o">=</span><span class="n">files</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">_format_response</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># batch mode is different: we need to compose a JSON request object</span>
            <span class="n">batched</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_batched</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;metadata&#39;</span><span class="p">,</span> <span class="n">json</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">batched</span><span class="o">.</span><span class="n">proc1</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s1">&#39;file&#39;</span><span class="p">:</span> <span class="n">f</span><span class="p">}))</span>
                <span class="k">yield</span> <span class="n">_format_response</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnexRepo.set_metadata"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.set_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">set_metadata</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">add</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">remove</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">purge</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Manipulate git-annex file-metadata</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        files : str or list(str)</span>
<span class="sd">          One or more paths for which metadata is to be manipulated.</span>
<span class="sd">          The changes applied to each file item are uniform. However,</span>
<span class="sd">          the result may not be uniform across files, depending on the</span>
<span class="sd">          actual operation.</span>
<span class="sd">        reset : dict, optional</span>
<span class="sd">          Metadata items matching keys in the given dict are (re)set</span>
<span class="sd">          to the respective values.</span>
<span class="sd">        add : dict, optional</span>
<span class="sd">          The values of matching keys in the given dict appended to</span>
<span class="sd">          any possibly existing values. The metadata keys need not</span>
<span class="sd">          necessarily exist before.</span>
<span class="sd">        init : dict, optional</span>
<span class="sd">          Metadata items for the keys in the given dict are set</span>
<span class="sd">          to the respective values, if the key is not yet present</span>
<span class="sd">          in a file&#39;s metadata.</span>
<span class="sd">        remove : dict, optional</span>
<span class="sd">          Values in the given dict are removed from the metadata items</span>
<span class="sd">          matching the respective key, if they exist in a file&#39;s metadata.</span>
<span class="sd">          Non-existing values, or keys do not lead to failure.</span>
<span class="sd">        purge : list, optional</span>
<span class="sd">          Any metadata item with a key matching an entry in the given</span>
<span class="sd">          list is removed from the metadata.</span>
<span class="sd">        recursive : bool, optional</span>
<span class="sd">          If False, fail (with CommandError) when directory paths</span>
<span class="sd">          are given as `files`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">          JSON obj per modified file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_metadata_</span><span class="p">(</span>
            <span class="n">files</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="n">reset</span><span class="p">,</span> <span class="n">add</span><span class="o">=</span><span class="n">add</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="n">init</span><span class="p">,</span>
            <span class="n">remove</span><span class="o">=</span><span class="n">remove</span><span class="p">,</span> <span class="n">purge</span><span class="o">=</span><span class="n">purge</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="n">recursive</span><span class="p">))</span></div>

<div class="viewcode-block" id="AnnexRepo.set_metadata_"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.set_metadata_">[docs]</a>    <span class="k">def</span> <span class="nf">set_metadata_</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">add</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">remove</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">purge</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Like set_metadata() but returns a generator&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_genspec</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">vs</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ensure_list</span><span class="p">(</span><span class="n">vs</span><span class="p">)]</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">expr</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">((</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">reset</span><span class="p">),</span>
                        <span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">+=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">add</span><span class="p">),</span>
                        <span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">?=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">init</span><span class="p">),</span>
                        <span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">-=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">remove</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">spec</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_genspec</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
        <span class="c1"># prefix all with &#39;-s&#39; and extend arg list</span>
        <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">j</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;-s&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">spec</span><span class="p">),</span> <span class="n">spec</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">purge</span><span class="p">:</span>
            <span class="c1"># and all &#39;-r&#39; args</span>
            <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">j</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;-r&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">purge</span><span class="p">),</span> <span class="n">purge</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">recursive</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;--force&#39;</span><span class="p">)</span>

        <span class="c1"># Make sure that batch add/addurl operations are closed so that we can</span>
        <span class="c1"># operate on files that were just added.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precommit</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">jsn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_annex_records</span><span class="p">(</span>
                <span class="p">[</span><span class="s1">&#39;metadata&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">args</span><span class="p">,</span>
                <span class="n">files</span><span class="o">=</span><span class="n">files</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">jsn</span></div>

    <span class="c1"># TODO: RM DIRECT?  might remain useful to detect submods left in direct mode</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_annex_work_tree_message</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span>
            <span class="sa">r</span><span class="s1">&#39;.*This operation must be run in a work tree.*&#39;</span>
            <span class="sa">r</span><span class="s1">&#39;git status.*failed in submodule&#39;</span><span class="p">,</span>
            <span class="n">out</span><span class="p">,</span>
            <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_mark_content_availability</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
        <span class="n">objectstore</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathobj</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">GitRepo</span><span class="o">.</span><span class="n">get_git_dir</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="s1">&#39;annex&#39;</span><span class="p">,</span> <span class="s1">&#39;objects&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="s1">&#39;key&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">r</span> <span class="ow">or</span> <span class="s1">&#39;has_content&#39;</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
                <span class="c1"># not annexed or already processed</span>
                <span class="k">continue</span>
            <span class="c1"># test hashdirmixed first, as it is used in non-bare repos</span>
            <span class="c1"># which be a more frequent target</span>
            <span class="c1"># TODO optimize order based on some check that reveals</span>
            <span class="c1"># what scheme is used in a given annex</span>
            <span class="n">r</span><span class="p">[</span><span class="s1">&#39;has_content&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">testpath</span> <span class="ow">in</span> <span class="p">(</span>
                    <span class="c1"># ATM git-annex reports hashdir in native path</span>
                    <span class="c1"># conventions and the actual file path `f` in</span>
                    <span class="c1"># POSIX, weird...</span>
                    <span class="c1"># we need to test for the actual key file, not</span>
                    <span class="c1"># just the containing dir, as on windows the latter</span>
                    <span class="c1"># may not always get cleaned up on `drop`</span>
                    <span class="n">objectstore</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span>
                        <span class="n">ut</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;hashdirmixed&#39;</span><span class="p">]),</span> <span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span>
                    <span class="n">objectstore</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span>
                        <span class="n">ut</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;hashdirlower&#39;</span><span class="p">]),</span> <span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">testpath</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                    <span class="n">r</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;hashdirlower&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="n">r</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;hashdirmixed&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="n">r</span><span class="p">[</span><span class="s1">&#39;objloc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">testpath</span><span class="p">)</span>
                    <span class="n">r</span><span class="p">[</span><span class="s1">&#39;has_content&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>

<div class="viewcode-block" id="AnnexRepo.get_file_annexinfo"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.get_file_annexinfo">[docs]</a>    <span class="k">def</span> <span class="nf">get_file_annexinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eval_availability</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">key_prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Query annex properties for a single file</span>

<span class="sd">        This is the companion to get_content_annexinfo() and offers</span>
<span class="sd">        simplified usage for single-file queries (the result lookup</span>
<span class="sd">        based on a path is not necessary.</span>

<span class="sd">        All keyword arguments have identical names and semantics as</span>
<span class="sd">        their get_content_annexinfo() counterparts. See their</span>
<span class="sd">        documentation for more information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : Path or str</span>
<span class="sd">          A single path to a file in the repository.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">          Keys and values match the values returned by get_content_annexinfo().</span>
<span class="sd">          If a file has no annex properties (i.e., a file that is directly</span>
<span class="sd">          checked into Git and is not annexed), the returned dictionary is</span>
<span class="sd">          empty.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">          When a given path is not matching a single file, but resolves to</span>
<span class="sd">          multiple files (e.g. a directory path)</span>
<span class="sd">        NoSuchPathError</span>
<span class="sd">          When the given path does not match any file in a repository</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">info</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_content_annexinfo</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">path</span><span class="p">],</span>
                    <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">ref</span><span class="o">=</span><span class="n">ref</span><span class="p">,</span>
                    <span class="n">eval_availability</span><span class="o">=</span><span class="n">eval_availability</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;AnnexRepo.get_file_annexinfo() can handle handle a single &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;file path, but </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2"> resolved to </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">info</span><span class="p">)</span><span class="si">}</span><span class="s2"> paths&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
            <span class="c1"># no error, there is a file, but we know nothing about it</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="n">path</span><span class="p">,</span> <span class="n">props</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
        <span class="c1"># turn a file not found situation into an exception</span>
        <span class="k">if</span> <span class="n">props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;success&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;note&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;not found&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoSuchPathError</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="c1"># fold path into the report to give easy access to a normalized,</span>
        <span class="c1"># resolved Path instance</span>
        <span class="n">props</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span>
        <span class="k">return</span> <span class="n">props</span></div>

<div class="viewcode-block" id="AnnexRepo.get_content_annexinfo"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.get_content_annexinfo">[docs]</a>    <span class="k">def</span> <span class="nf">get_content_annexinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">paths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="s1">&#39;git&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eval_availability</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">key_prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        paths : list or None</span>
<span class="sd">          Specific paths to query info for. In `None`, info is reported for all</span>
<span class="sd">          content.</span>
<span class="sd">        init : &#39;git&#39; or dict-like or None</span>
<span class="sd">          If set to &#39;git&#39; annex content info will amend the output of</span>
<span class="sd">          GitRepo.get_content_info(), otherwise the dict-like object</span>
<span class="sd">          supplied will receive this information and the present keys will</span>
<span class="sd">          limit the report of annex properties. Alternatively, if `None`</span>
<span class="sd">          is given, no initialization is done, and no limit is in effect.</span>
<span class="sd">        ref : gitref or None</span>
<span class="sd">          If not None, annex content info for this Git reference will be</span>
<span class="sd">          produced, otherwise for the content of the present worktree.</span>
<span class="sd">        eval_availability : bool</span>
<span class="sd">          If this flag is given, evaluate whether the content of any annex&#39;ed</span>
<span class="sd">          file is present in the local annex.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">          Additional arguments for GitRepo.get_content_info(), if `init` is</span>
<span class="sd">          set to &#39;git&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">          The keys/values match those reported by GitRepo.get_content_info().</span>
<span class="sd">          In addition, the following properties are added to each value</span>
<span class="sd">          dictionary:</span>

<span class="sd">          `type`</span>
<span class="sd">            Can be &#39;file&#39;, &#39;symlink&#39;, &#39;dataset&#39;, &#39;directory&#39;, where &#39;file&#39;</span>
<span class="sd">            is also used for annex&#39;ed files (corrects a &#39;symlink&#39; report</span>
<span class="sd">            made by `get_content_info()`.</span>
<span class="sd">          `key`</span>
<span class="sd">            Annex key of a file (if an annex&#39;ed file)</span>
<span class="sd">          `bytesize`</span>
<span class="sd">            Size of an annexed file in bytes.</span>
<span class="sd">          `has_content`</span>
<span class="sd">            Bool whether a content object for this key exists in the local</span>
<span class="sd">            annex (with `eval_availability`)</span>
<span class="sd">          `objloc`</span>
<span class="sd">            pathlib.Path of the content object in the local annex, if one</span>
<span class="sd">            is available (with `eval_availability`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">init</span> <span class="o">==</span> <span class="s1">&#39;git&#39;</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">AnnexRepo</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_content_info</span><span class="p">(</span>
                <span class="n">paths</span><span class="o">=</span><span class="n">paths</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">ref</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="n">init</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">paths</span> <span class="ow">and</span> <span class="n">paths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">info</span>

        <span class="c1"># use this funny-looking option with both find and findref</span>
        <span class="c1"># it takes care of git-annex reporting on any known key, regardless</span>
        <span class="c1"># of whether or not it actually (did) exist in the local annex</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;--copies&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">]</span>
        <span class="n">files</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">ref</span><span class="p">:</span>
            <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;findref&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">cmd</span>
            <span class="n">cmd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;find&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">cmd</span>
            <span class="c1"># stringify any pathobjs</span>
            <span class="k">if</span> <span class="n">paths</span><span class="p">:</span>
                <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cmd</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;--include&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_annex_records</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="n">files</span><span class="p">):</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathobj</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">PurePosixPath</span><span class="p">(</span><span class="n">j</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]))</span>
            <span class="n">rec</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># init constraint knows nothing about this path -&gt; skip</span>
                    <span class="k">continue</span>
                <span class="n">rec</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">rec</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;</span><span class="si">{}{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key_prefix</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span> <span class="n">j</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                       <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">j</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s1">&#39;file&#39;</span><span class="p">})</span>
            <span class="k">if</span> <span class="s1">&#39;bytesize&#39;</span> <span class="ow">in</span> <span class="n">rec</span><span class="p">:</span>
                <span class="c1"># it makes sense to make this an int that one can calculate with</span>
                <span class="c1"># with</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">rec</span><span class="p">[</span><span class="s1">&#39;bytesize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rec</span><span class="p">[</span><span class="s1">&#39;bytesize&#39;</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="c1"># this would only ever happen, if the recorded key itself</span>
                    <span class="c1"># has no size info. Even for a URL key, this would mean</span>
                    <span class="c1"># that the server would have to not report size info at all</span>
                    <span class="c1"># but it does actually happen, e.g.</span>
                    <span class="c1"># URL--http&amp;c%%ciml.info%dl%v0_9%ciml-v0_9-all.pdf</span>
                    <span class="c1"># from github.com/datalad-datasets/machinelearning-books</span>
                    <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Failed to convert &quot;</span><span class="si">%s</span><span class="s1">&quot; to integer bytesize&#39;</span><span class="p">,</span>
                              <span class="n">rec</span><span class="p">[</span><span class="s1">&#39;bytesize&#39;</span><span class="p">])</span>
                    <span class="c1"># remove the field completely to avoid ambiguous semantics</span>
                    <span class="c1"># of None/NaN etc.</span>
                    <span class="k">del</span> <span class="n">rec</span><span class="p">[</span><span class="s1">&#39;bytesize&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">rec</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;symlink&#39;</span> <span class="ow">and</span> <span class="n">rec</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># we have a tracked symlink with an associated annex key</span>
                <span class="c1"># this is only a symlink for technical reasons, but actually</span>
                <span class="c1"># a file from the user perspective.</span>
                <span class="c1"># homogenization of this kind makes the report more robust</span>
                <span class="c1"># across different representations of a repo</span>
                <span class="c1"># (think adjusted branches ...)</span>
                <span class="n">rec</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;file&#39;</span>
            <span class="n">info</span><span class="p">[</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="n">rec</span>
        <span class="c1"># TODO make annex availability checks optional and move in here</span>
        <span class="k">if</span> <span class="n">eval_availability</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mark_content_availability</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">info</span></div>

<div class="viewcode-block" id="AnnexRepo.annexstatus"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.annexstatus">[docs]</a>    <span class="k">def</span> <span class="nf">annexstatus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">untracked</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_content_annexinfo</span><span class="p">(</span>
            <span class="n">paths</span><span class="o">=</span><span class="n">paths</span><span class="p">,</span>
            <span class="n">eval_availability</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_content_annexinfo</span><span class="p">(</span>
                <span class="n">paths</span><span class="o">=</span><span class="n">paths</span><span class="p">,</span>
                <span class="n">ref</span><span class="o">=</span><span class="s1">&#39;HEAD&#39;</span><span class="p">,</span>
                <span class="n">eval_availability</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="p">(</span>
                    <span class="n">paths</span><span class="o">=</span><span class="n">paths</span><span class="p">,</span>
                    <span class="n">eval_submodule_state</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mark_content_availability</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">info</span></div>

    <span class="k">def</span> <span class="nf">_save_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">git</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">git_opts</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Simple helper to add files in save()&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">datalad.interface.results</span> <span class="kn">import</span> <span class="n">get_status_dict</span>
        <span class="c1"># alter default behavior of git-annex by considering dotfiles</span>
        <span class="c1"># too</span>
        <span class="c1"># however, this helper is controlled by save() which itself</span>
        <span class="c1"># operates on status() which itself honors .gitignore, so</span>
        <span class="c1"># there is a standard mechanism that is uniform between Git</span>
        <span class="c1"># Annex repos to decide on the behavior on a case-by-case</span>
        <span class="c1"># basis</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># if None -- leave it to annex to decide</span>
        <span class="k">if</span> <span class="n">git</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;--force-large&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">on_windows</span><span class="p">:</span>
            <span class="c1"># git-annex ignores symlinks on windows</span>
            <span class="c1"># https://github.com/datalad/datalad/issues/2955</span>
            <span class="c1"># check if there are any and pass them to git-add</span>
            <span class="n">symlinks_toadd</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">p</span><span class="p">:</span> <span class="n">props</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">props</span> <span class="ow">in</span> <span class="n">files</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;symlink&#39;</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">symlinks_toadd</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">GitRepo</span><span class="o">.</span><span class="n">_save_add</span><span class="p">(</span>
                        <span class="bp">self</span><span class="p">,</span>
                        <span class="n">symlinks_toadd</span><span class="p">,</span>
                        <span class="n">git_opts</span><span class="o">=</span><span class="n">git_opts</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">r</span>
            <span class="c1"># trim `files` of symlinks</span>
            <span class="n">files</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">p</span><span class="p">:</span> <span class="n">props</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">props</span> <span class="ow">in</span> <span class="n">files</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="s1">&#39;symlink&#39;</span><span class="p">}</span>

        <span class="n">expected_additions</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">ui</span><span class="o">.</span><span class="n">is_interactive</span><span class="p">:</span>
            <span class="c1"># without an interactive UI there is little benefit from</span>
            <span class="c1"># progressbar info, hence save the stat calls</span>
            <span class="n">expected_additions</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_file_size</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">files</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">git</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="n">GitRepo</span><span class="o">.</span><span class="n">_save_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">git_opts</span><span class="o">=</span><span class="n">git_opts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_annex_records</span><span class="p">(</span>
                    <span class="p">[</span><span class="s1">&#39;add&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">options</span><span class="p">,</span>
                    <span class="n">files</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">files</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                    <span class="c1"># TODO</span>
                    <span class="n">jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">total_nbytes</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">expected_additions</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                    <span class="k">if</span> <span class="n">expected_additions</span> <span class="k">else</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">get_status_dict</span><span class="p">(</span>
                    <span class="n">action</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;command&#39;</span><span class="p">,</span> <span class="s1">&#39;add&#39;</span><span class="p">),</span>
                    <span class="n">refds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pathobj</span><span class="p">,</span>
                    <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;file&#39;</span><span class="p">,</span>
                    <span class="n">path</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathobj</span> <span class="o">/</span> <span class="n">ut</span><span class="o">.</span><span class="n">PurePosixPath</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="s1">&#39;file&#39;</span> <span class="ow">in</span> <span class="n">r</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">status</span><span class="o">=</span><span class="s1">&#39;ok&#39;</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;success&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span>
                    <span class="n">key</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="n">message</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;error-messages&#39;</span><span class="p">])</span>
                    <span class="k">if</span> <span class="s1">&#39;error-messages&#39;</span> <span class="ow">in</span> <span class="n">r</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">logger</span><span class="o">=</span><span class="n">lgr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_save_post</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">partial_commit</span><span class="p">,</span>
                   <span class="n">amend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_empty</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">amend</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_managed_branch</span><span class="p">()</span> <span class="ow">and</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">format_commit</span><span class="p">(</span><span class="s2">&quot;%B&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;git-annex adjusted branch&quot;</span><span class="p">:</span>
            <span class="c1"># We must not directly amend on an adjusted branch, but fix it</span>
            <span class="c1"># up after the fact. That is if HEAD is a git-annex commit.</span>
            <span class="c1"># Otherwise we still can amend-commit normally.</span>
            <span class="c1"># Note, that this may involve creating an empty commit first.</span>
            <span class="n">amend</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">adjust_amend</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">adjust_amend</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># first do standard GitRepo business</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AnnexRepo</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_save_post</span><span class="p">(</span>
            <span class="n">message</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">partial_commit</span><span class="p">,</span> <span class="n">amend</span><span class="p">,</span>
            <span class="n">allow_empty</span><span class="o">=</span><span class="n">allow_empty</span> <span class="ow">or</span> <span class="n">adjust_amend</span><span class="p">)</span>
        <span class="c1"># then sync potential managed branches</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">localsync</span><span class="p">(</span><span class="n">managed_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">adjust_amend</span><span class="p">:</span>
            <span class="c1"># We committed in an adjusted branch, but the goal is to amend in</span>
            <span class="c1"># corresponding branch.</span>

            <span class="n">adjusted_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_active_branch</span><span class="p">()</span>
            <span class="n">corresponding_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_corresponding_branch</span><span class="p">()</span>
            <span class="n">old_sha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hexsha</span><span class="p">(</span><span class="n">corresponding_branch</span><span class="p">)</span>

            <span class="n">org_commit_pointer</span> <span class="o">=</span> <span class="n">corresponding_branch</span> <span class="o">+</span> <span class="s2">&quot;~1&quot;</span>
            <span class="n">author_name</span><span class="p">,</span> <span class="n">author_email</span><span class="p">,</span> <span class="n">author_date</span><span class="p">,</span> \
            <span class="n">old_parent</span><span class="p">,</span> <span class="n">old_message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_commit</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%a</span><span class="s2">n</span><span class="si">%x</span><span class="s2">00</span><span class="si">%a</span><span class="s2">e</span><span class="si">%x</span><span class="s2">00</span><span class="si">%a</span><span class="s2">d</span><span class="si">%x</span><span class="s2">00%P</span><span class="si">%x</span><span class="s2">00%B&quot;</span><span class="p">,</span> <span class="n">org_commit_pointer</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">new_env</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_git_runner</span><span class="o">.</span><span class="n">env</span>
                       <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_git_runner</span><span class="o">.</span><span class="n">env</span> <span class="k">else</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># `message` might be empty - we need to take it from the to be</span>
            <span class="c1"># amended commit in that case:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">message</span> <span class="ow">or</span> <span class="n">old_message</span>
            <span class="n">new_env</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                <span class="s1">&#39;GIT_AUTHOR_NAME&#39;</span><span class="p">:</span> <span class="n">author_name</span><span class="p">,</span>
                <span class="s1">&#39;GIT_AUTHOR_EMAIL&#39;</span><span class="p">:</span> <span class="n">author_email</span><span class="p">,</span>
                <span class="s1">&#39;GIT_AUTHOR_DATE&#39;</span><span class="p">:</span> <span class="n">author_date</span>
            <span class="p">})</span>
            <span class="n">commit_cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;commit-tree&quot;</span><span class="p">,</span>
                          <span class="n">corresponding_branch</span> <span class="o">+</span> <span class="s2">&quot;^</span><span class="si">{tree}</span><span class="s2">&quot;</span><span class="p">,</span>
                          <span class="s2">&quot;-m&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">old_parent</span><span class="p">:</span>
                <span class="n">commit_cmd</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;-p&quot;</span><span class="p">,</span> <span class="n">old_parent</span><span class="p">])</span>
            <span class="n">out</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_git</span><span class="p">(</span><span class="n">commit_cmd</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="n">new_env</span><span class="p">,</span> <span class="n">read_only</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">new_sha</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">update_ref</span><span class="p">(</span><span class="s2">&quot;refs/heads/&quot;</span> <span class="o">+</span> <span class="n">corresponding_branch</span><span class="p">,</span>
                            <span class="n">new_sha</span><span class="p">,</span> <span class="n">old_sha</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_ref</span><span class="p">(</span><span class="s2">&quot;refs/basis/&quot;</span> <span class="o">+</span> <span class="n">adjusted_branch</span><span class="p">,</span>
                            <span class="n">new_sha</span><span class="p">,</span> <span class="n">old_sha</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">localsync</span><span class="p">(</span><span class="n">managed_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="AnnexRepo.localsync"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexRepo.localsync">[docs]</a>    <span class="k">def</span> <span class="nf">localsync</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remote</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">managed_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Consolidate the local git-annex branch and/or managed branches.</span>

<span class="sd">        This method calls `git annex sync` to perform purely local operations</span>
<span class="sd">        that:</span>

<span class="sd">        1. Update the corresponding branch of any managed branch.</span>

<span class="sd">        2. Synchronize the local &#39;git-annex&#39; branch with respect to particular</span>
<span class="sd">           or all remotes (as currently reflected in the local state of their</span>
<span class="sd">           remote &#39;git-annex&#39; branches).</span>

<span class="sd">        If a repository has git-annex&#39;s &#39;synced/...&#39; branches these will be</span>
<span class="sd">        updated.  Otherwise, such branches that are created by `git annex sync`</span>
<span class="sd">        are removed again after the sync is complete.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        remote : str or list, optional</span>
<span class="sd">          If given, specifies the name of one or more remotes to sync against.</span>
<span class="sd">          If not given, all remotes are considered.</span>
<span class="sd">        managed_only : bool, optional</span>
<span class="sd">          Only perform a sync if a managed branch with a corresponding branch</span>
<span class="sd">          is detected. By default, a sync is always performed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_active_branch</span><span class="p">()</span>
        <span class="n">corresponding_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_corresponding_branch</span><span class="p">(</span><span class="n">branch</span><span class="p">)</span>
        <span class="n">branch</span> <span class="o">=</span> <span class="n">corresponding_branch</span> <span class="ow">or</span> <span class="n">branch</span>

        <span class="k">if</span> <span class="n">managed_only</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">corresponding_branch</span><span class="p">:</span>
            <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;No sync necessary, no corresponding branch detected&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Sync local &#39;git-annex&#39; branch</span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span>
            <span class="s2">&quot;, and corresponding &#39;</span><span class="si">{}</span><span class="s2">&#39; branch&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">corresponding_branch</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">corresponding_branch</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="n">synced_branch</span> <span class="o">=</span> <span class="s1">&#39;synced/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">branch</span><span class="p">)</span>
        <span class="n">had_synced_branch</span> <span class="o">=</span> <span class="n">synced_branch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_branches</span><span class="p">()</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;sync&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">remote</span><span class="p">:</span>
            <span class="n">cmd</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ensure_list</span><span class="p">(</span><span class="n">remote</span><span class="p">))</span>
        <span class="n">cmd</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="c1"># disable any external interaction and other magic</span>
            <span class="s1">&#39;--no-push&#39;</span><span class="p">,</span> <span class="s1">&#39;--no-pull&#39;</span><span class="p">,</span> <span class="s1">&#39;--no-commit&#39;</span><span class="p">,</span> <span class="s1">&#39;--no-resolvemerge&#39;</span><span class="p">,</span>
            <span class="s1">&#39;--no-content&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">call_annex</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
        <span class="c1"># a sync can establish new config (e.g. annex-uuid for a remote)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">reload</span><span class="p">()</span>
        <span class="c1"># cleanup sync&#39;ed branch if we caused it</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">had_synced_branch</span> <span class="ow">and</span> <span class="n">synced_branch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_branches</span><span class="p">():</span>
            <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Remove previously non-existent </span><span class="si">%s</span><span class="s1"> branch after sync&#39;</span><span class="p">,</span>
                      <span class="n">synced_branch</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">call_git</span><span class="p">(</span>
                <span class="p">[</span><span class="s1">&#39;branch&#39;</span><span class="p">,</span> <span class="s1">&#39;-d&#39;</span><span class="p">,</span> <span class="n">synced_branch</span><span class="p">],</span>
            <span class="p">)</span></div></div>


<div class="viewcode-block" id="AnnexJsonProtocol"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexJsonProtocol">[docs]</a><span class="k">class</span> <span class="nc">AnnexJsonProtocol</span><span class="p">(</span><span class="n">WitlessProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Subprocess communication protocol for `annex ... --json` commands</span>

<span class="sd">    Importantly, parsed JSON content is returned as a result, not string output.</span>

<span class="sd">    This protocol also handles git-annex&#39;s JSON-style progress reporting.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># capture both streams and handle messaging completely</span>
    <span class="n">proc_out</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">proc_err</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">done_future</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">total_nbytes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">done_future</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;`done_future` argument is ignored &quot;</span>
                          <span class="s2">&quot;and will be removed in a future release&quot;</span><span class="p">,</span>
                          <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># to collect parsed JSON command output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">json_out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_global_pbar_id</span> <span class="o">=</span> <span class="s1">&#39;annexprogress-</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_nbytes</span> <span class="o">=</span> <span class="n">total_nbytes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unprocessed</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="AnnexJsonProtocol.add_to_output"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexJsonProtocol.add_to_output">[docs]</a>    <span class="k">def</span> <span class="nf">add_to_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_object</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">json_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">json_object</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnexJsonProtocol.connection_made"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexJsonProtocol.connection_made">[docs]</a>    <span class="k">def</span> <span class="nf">connection_made</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transport</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">connection_made</span><span class="p">(</span><span class="n">transport</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pbars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># overall counter of processed bytes (computed from key reports)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_byte_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbytes</span><span class="p">:</span>
            <span class="c1"># init global pbar, do here to be on top of first file</span>
            <span class="n">log_progress</span><span class="p">(</span>
                <span class="n">lgr</span><span class="o">.</span><span class="n">info</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_global_pbar_id</span><span class="p">,</span>
                <span class="s1">&#39;Start annex operation&#39;</span><span class="p">,</span>
                <span class="c1"># do not crash if no command is reported</span>
                <span class="n">unit</span><span class="o">=</span><span class="s1">&#39; Bytes&#39;</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Total&#39;</span><span class="p">,</span>
                <span class="n">total</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">total_nbytes</span><span class="p">,</span>
                <span class="n">noninteractive_level</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pbars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_global_pbar_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnexJsonProtocol.pipe_data_received"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexJsonProtocol.pipe_data_received">[docs]</a>    <span class="k">def</span> <span class="nf">pipe_data_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fd</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># let the base class decide what to do with it</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">pipe_data_received</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unprocessed</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unprocessed</span> <span class="o">+</span> <span class="n">data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unprocessed</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># this is where the JSON records come in</span>
        <span class="c1"># json_loads() is already logging any error, which is OK, because</span>
        <span class="c1"># under no circumstances we would expect broken JSON</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">iline</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">json_loads</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                    <span class="c1"># do not complain on empty lines</span>
                    <span class="k">if</span> <span class="n">iline</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="o">.</span><span class="n">encode</span><span class="p">()):</span>
                        <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Caught </span><span class="si">%s</span><span class="s2"> while trying to parse JSON line </span><span class="si">%s</span><span class="s2"> which might &quot;</span>
                                  <span class="s2">&quot;be not yet a full line&quot;</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                        <span class="c1"># it is the last line and fails to parse -- it can/likely</span>
                        <span class="c1"># to happen that it was not a complete line and that buffer</span>
                        <span class="c1"># got filled up/provided before the end of line.</span>
                        <span class="c1"># Store it so that it can be prepended to data in the next call.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_unprocessed</span> <span class="o">=</span> <span class="n">line</span>
                        <span class="k">break</span>
                    <span class="c1"># TODO turn this into an error result, or put the exception</span>
                    <span class="c1"># onto the result future -- needs more thought</span>
                    <span class="n">lgr</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Received undecodable JSON output: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_proc_json_record</span><span class="p">(</span><span class="n">j</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_pbar_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="c1"># NOTE: Look at the &quot;action&quot; field for byte-progress records and the</span>
        <span class="c1"># top-level `record` for the final record. The action record as a whole</span>
        <span class="c1"># should be stable link across byte-progress records, but a subset of</span>
        <span class="c1"># the keys is hard coded below so that the action record can be linked</span>
        <span class="c1"># to the final one.</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;action&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">record</span>
        <span class="k">return</span> <span class="s1">&#39;annexprogress-</span><span class="si">{}</span><span class="s1">-</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="nb">hash</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                           <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;command&quot;</span><span class="p">,</span> <span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="s2">&quot;file&quot;</span><span class="p">])))</span>

    <span class="k">def</span> <span class="nf">_get_pbar_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">):</span>
        <span class="c1"># do not crash if no command is reported</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">action</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;command&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">action</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;file&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">action</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">target</span>

        <span class="k">if</span> <span class="n">label</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">datalad.ui</span> <span class="kn">import</span> <span class="n">utils</span> <span class="k">as</span> <span class="n">ui_utils</span>
            <span class="c1"># Reserving 55 characters for the progress bar is based</span>
            <span class="c1"># approximately off what used to be done in the now-removed</span>
            <span class="c1"># (948ccf3e18) ProcessAnnexProgressIndicators.</span>
            <span class="n">max_label_width</span> <span class="o">=</span> <span class="n">ui_utils</span><span class="o">.</span><span class="n">get_console_width</span><span class="p">()</span> <span class="o">-</span> <span class="mi">55</span>
            <span class="k">if</span> <span class="n">max_label_width</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># We&#39;re squeezed. Just show bar.</span>
                <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_label_width</span><span class="p">:</span>
                <span class="n">mid</span> <span class="o">=</span> <span class="n">max_label_width</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">label</span><span class="p">[:</span><span class="n">mid</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot; .. &quot;</span> <span class="o">+</span> <span class="n">label</span><span class="p">[</span><span class="o">-</span><span class="n">mid</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">label</span>

    <span class="k">def</span> <span class="nf">_proc_json_record</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="c1"># check for progress reports and act on them immediately</span>
        <span class="c1"># but only if there is something to build a progress report from</span>
        <span class="n">pbar_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_pbar_id</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="n">known_pbar</span> <span class="o">=</span> <span class="n">pbar_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pbars</span>
        <span class="n">action</span> <span class="o">=</span> <span class="n">j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;action&#39;</span><span class="p">)</span>

        <span class="n">is_progress</span> <span class="o">=</span> <span class="n">action</span> <span class="ow">and</span> <span class="s1">&#39;byte-progress&#39;</span> <span class="ow">in</span> <span class="n">j</span>
        <span class="c1"># ignore errors repeatedly reported in progress messages. Final message</span>
        <span class="c1"># will contain them</span>
        <span class="k">if</span> <span class="n">action</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_progress</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">err_msg</span> <span class="ow">in</span> <span class="n">action</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;error-messages&#39;</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="n">lgr</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">known_pbar</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is_progress</span> <span class="ow">or</span>
                           <span class="n">j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;byte-progress&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;total-size&#39;</span><span class="p">)):</span>
            <span class="c1"># take a known pbar down, completion or broken report</span>
            <span class="n">log_progress</span><span class="p">(</span>
                <span class="n">lgr</span><span class="o">.</span><span class="n">info</span><span class="p">,</span>
                <span class="n">pbar_id</span><span class="p">,</span>
                <span class="s1">&#39;Finished annex action: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">action</span><span class="p">),</span>
                <span class="n">noninteractive_level</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pbars</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">pbar_id</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_progress</span><span class="p">:</span>
                <span class="c1"># The final record is yet to come.</span>
                <span class="k">return</span>

        <span class="k">if</span> <span class="n">is_progress</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">known_pbar</span><span class="p">:</span>
                <span class="c1"># init the pbar, the is some progress left to be made</span>
                <span class="c1"># worth it</span>
                <span class="n">log_progress</span><span class="p">(</span>
                    <span class="n">lgr</span><span class="o">.</span><span class="n">info</span><span class="p">,</span>
                    <span class="n">pbar_id</span><span class="p">,</span>
                    <span class="s1">&#39;Start annex action: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">action</span><span class="p">),</span>
                    <span class="n">label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_pbar_label</span><span class="p">(</span><span class="n">action</span><span class="p">),</span>
                    <span class="n">unit</span><span class="o">=</span><span class="s1">&#39; Bytes&#39;</span><span class="p">,</span>
                    <span class="n">total</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;total-size&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
                    <span class="n">noninteractive_level</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pbars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pbar_id</span><span class="p">)</span>
            <span class="n">log_progress</span><span class="p">(</span>
                <span class="n">lgr</span><span class="o">.</span><span class="n">info</span><span class="p">,</span>
                <span class="n">pbar_id</span><span class="p">,</span>
                <span class="n">j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;percent-progress&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="n">update</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;byte-progress&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
                <span class="n">noninteractive_level</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># do not let progress reports leak into the return value</span>
            <span class="k">return</span>
        <span class="c1"># update overall progress, do not crash when there is no key property</span>
        <span class="c1"># in the report (although there should be one)</span>
        <span class="n">key_bytes</span> <span class="o">=</span> <span class="n">AnnexRepo</span><span class="o">.</span><span class="n">get_size_from_key</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">key_bytes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_byte_count</span> <span class="o">+=</span> <span class="n">key_bytes</span>
        <span class="c1"># don&#39;t do anything to the results for now in terms of normalization</span>
        <span class="c1"># TODO the protocol could be made aware of the runner&#39;s CWD and</span>
        <span class="c1"># also any dataset the annex command is operating on. This would</span>
        <span class="c1"># enable &#39;file&#39; property conversion to absolute paths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_to_output</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbytes</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbytes</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_byte_count</span><span class="p">:</span>
                <span class="c1"># discard global pbar</span>
                <span class="n">log_progress</span><span class="p">(</span>
                    <span class="n">lgr</span><span class="o">.</span><span class="n">info</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_global_pbar_id</span><span class="p">,</span>
                    <span class="s1">&#39;Finished annex </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;command&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)),</span>
                    <span class="n">noninteractive_level</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pbars</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_global_pbar_id</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># log actual progress</span>
                <span class="n">log_progress</span><span class="p">(</span>
                    <span class="n">lgr</span><span class="o">.</span><span class="n">info</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_global_pbar_id</span><span class="p">,</span>
                    <span class="n">j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span>
                    <span class="n">update</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_byte_count</span><span class="p">,</span>
                    <span class="n">noninteractive_level</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_prepare_result</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># first let the base class do its thing</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_prepare_result</span><span class="p">()</span>
        <span class="c1"># now amend the results, make clear in the key-name that these records</span>
        <span class="c1"># came from stdout -- may not be important here or now, but it is easy</span>
        <span class="c1"># to imagine structured output on stderr at some point</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;stdout_json&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_out</span>
        <span class="k">return</span> <span class="n">results</span>

<div class="viewcode-block" id="AnnexJsonProtocol.process_exited"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexJsonProtocol.process_exited">[docs]</a>    <span class="k">def</span> <span class="nf">process_exited</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># take down any progress bars that were not closed orderly</span>
        <span class="k">for</span> <span class="n">pbar_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pbars</span><span class="p">:</span>
            <span class="n">log_progress</span><span class="p">(</span>
                <span class="n">lgr</span><span class="o">.</span><span class="n">info</span><span class="p">,</span>
                <span class="n">pbar_id</span><span class="p">,</span>
                <span class="s1">&#39;Finished&#39;</span><span class="p">,</span>
                <span class="n">noninteractive_level</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unprocessed</span><span class="p">:</span>
            <span class="n">lgr</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> bytes of received undecodable JSON output remain: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unprocessed</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unprocessed</span>
            <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">process_exited</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="GeneratorAnnexJsonProtocol"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.GeneratorAnnexJsonProtocol">[docs]</a><span class="k">class</span> <span class="nc">GeneratorAnnexJsonProtocol</span><span class="p">(</span><span class="n">GeneratorMixIn</span><span class="p">,</span> <span class="n">AnnexJsonProtocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">done_future</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">total_nbytes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">GeneratorMixIn</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">AnnexJsonProtocol</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">done_future</span><span class="p">,</span> <span class="n">total_nbytes</span><span class="p">)</span>

<div class="viewcode-block" id="GeneratorAnnexJsonProtocol.add_to_output"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.GeneratorAnnexJsonProtocol.add_to_output">[docs]</a>    <span class="k">def</span> <span class="nf">add_to_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_object</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_result</span><span class="p">(</span><span class="n">json_object</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="AnnexInitOutput"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexInitOutput">[docs]</a><span class="k">class</span> <span class="nc">AnnexInitOutput</span><span class="p">(</span><span class="n">WitlessProtocol</span><span class="p">):</span>
    <span class="n">proc_out</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">proc_err</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="AnnexInitOutput.pipe_data_received"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.AnnexInitOutput.pipe_data_received">[docs]</a>    <span class="k">def</span> <span class="nf">pipe_data_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">byts</span><span class="p">):</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">byts</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fd</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;(scanning for .* files)&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
                <span class="n">lgr</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> (this may take some time)&quot;</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">fd</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">lgr</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span></div></div>


<span class="c1"># TODO: Why was this commented out?</span>
<span class="c1"># @auto_repr</span>
<div class="viewcode-block" id="BatchedAnnexes"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.BatchedAnnexes">[docs]</a><span class="k">class</span> <span class="nc">BatchedAnnexes</span><span class="p">(</span><span class="n">SafeDelCloseMixin</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to contain the registry of active batch&#39;ed instances of annex for</span>
<span class="sd">    a repository</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">git_options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">git_options</span> <span class="o">=</span> <span class="n">git_options</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BatchedAnnexes</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

<div class="viewcode-block" id="BatchedAnnexes.get"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.BatchedAnnexes.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">codename</span><span class="p">,</span> <span class="n">annex_cmd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">annex_cmd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">annex_cmd</span> <span class="o">=</span> <span class="n">codename</span>

        <span class="n">git_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">git_options</span> <span class="o">+</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;git_options&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">:</span>
            <span class="n">git_options</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;-c&#39;</span><span class="p">,</span> <span class="s1">&#39;annex.queuesize=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">]</span>

        <span class="c1"># START RF/BF: extend codename to respect different options the process</span>
        <span class="c1"># is running with</span>
        <span class="c1"># TODO: Eventually there should be more RF&#39;ing, since the actually used</span>
        <span class="c1"># codenames are partially reflecting this already. Any options used</span>
        <span class="c1"># therein should go away, since they are now automatically included.</span>
        <span class="n">options</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">options</span><span class="p">[</span><span class="s1">&#39;git_options&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">git_options</span>
        <span class="n">options</span><span class="p">[</span><span class="s1">&#39;annex_cmd&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">annex_cmd</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
            <span class="n">codename</span> <span class="o">+=</span> <span class="s1">&#39;:</span><span class="si">{0}</span><span class="s1">:</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="c1"># END RF/BF</span>

        <span class="k">if</span> <span class="n">codename</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># Create a new git-annex process we will keep around</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">codename</span><span class="p">]</span> <span class="o">=</span> <span class="n">BatchedAnnex</span><span class="p">(</span><span class="n">annex_cmd</span><span class="p">,</span>
                                          <span class="n">git_options</span><span class="o">=</span><span class="n">git_options</span><span class="p">,</span>
                                          <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">codename</span><span class="p">]</span></div>

<div class="viewcode-block" id="BatchedAnnexes.clear"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.BatchedAnnexes.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Override just to make sure we don&#39;t rely on __del__ to close all</span>
<span class="sd">        the pipes&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BatchedAnnexes</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>

<div class="viewcode-block" id="BatchedAnnexes.close"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.BatchedAnnexes.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Close communication to all the batched annexes</span>

<span class="sd">        It does not remove them from the dictionary though</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="readlines_until_ok_or_failed"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.readlines_until_ok_or_failed">[docs]</a><span class="k">def</span> <span class="nf">readlines_until_ok_or_failed</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="n">maxlines</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Read stdout until line ends with ok or failed&quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">lgr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;Trying to receive from </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">stdout</span><span class="p">)</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">stdout</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">maxlines</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">maxlines</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Expected no more than </span><span class="si">%d</span><span class="s2"> lines. So far received: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">maxlines</span><span class="p">,</span> <span class="n">out</span><span class="p">))</span>
        <span class="n">lgr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Expecting a line&quot;</span><span class="p">)</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">stdout</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="n">lgr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Received line </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="n">line</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^.*\b(failed|ok)$&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()):</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span></div>


<div class="viewcode-block" id="readline_json"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.readline_json">[docs]</a><span class="k">def</span> <span class="nf">readline_json</span><span class="p">(</span><span class="n">stdout</span><span class="p">):</span>
    <span class="n">toload</span> <span class="o">=</span> <span class="n">stdout</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">json_loads</span><span class="p">(</span><span class="n">toload</span><span class="p">)</span> <span class="k">if</span> <span class="n">toload</span> <span class="k">else</span> <span class="p">{}</span></div>


<div class="viewcode-block" id="BatchedAnnex"><a class="viewcode-back" href="../../../generated/datalad.support.annexrepo.html#datalad.support.annexrepo.BatchedAnnex">[docs]</a><span class="nd">@auto_repr</span>
<span class="k">class</span> <span class="nc">BatchedAnnex</span><span class="p">(</span><span class="n">BatchedCommand</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Container for an annex process which would allow for persistent communication</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annex_cmd</span><span class="p">,</span> <span class="n">git_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">annex_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">json</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output_proc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annex_cmd</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">annex_cmd</span> <span class="o">=</span> <span class="p">[</span><span class="n">annex_cmd</span><span class="p">]</span>
        <span class="n">cmd</span> <span class="o">=</span> \
            <span class="p">[</span><span class="s1">&#39;git&#39;</span><span class="p">]</span> <span class="o">+</span> \
            <span class="p">(</span><span class="n">git_options</span> <span class="k">if</span> <span class="n">git_options</span> <span class="k">else</span> <span class="p">[])</span> <span class="o">+</span> \
            <span class="p">[</span><span class="s1">&#39;annex&#39;</span><span class="p">]</span> <span class="o">+</span> \
            <span class="n">annex_cmd</span> <span class="o">+</span> \
            <span class="p">(</span><span class="n">annex_options</span> <span class="k">if</span> <span class="n">annex_options</span> <span class="k">else</span> <span class="p">[])</span> <span class="o">+</span> \
            <span class="p">([</span><span class="s1">&#39;--json&#39;</span><span class="p">,</span> <span class="s1">&#39;--json-error-messages&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">json</span> <span class="k">else</span> <span class="p">[])</span> <span class="o">+</span> \
            <span class="p">[</span><span class="s1">&#39;--batch&#39;</span><span class="p">]</span> <span class="o">+</span> \
            <span class="p">([</span><span class="s1">&#39;--debug&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">lgr</span><span class="o">.</span><span class="n">getEffectiveLevel</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">8</span> <span class="k">else</span> <span class="p">[])</span>
        <span class="n">output_proc</span> <span class="o">=</span> \
            <span class="n">output_proc</span> <span class="k">if</span> <span class="n">output_proc</span> <span class="k">else</span> <span class="n">readline_json</span> <span class="k">if</span> <span class="n">json</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BatchedAnnex</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">cmd</span><span class="p">,</span>
            <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span>
            <span class="n">output_proc</span><span class="o">=</span><span class="n">output_proc</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2022, DataLad team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>